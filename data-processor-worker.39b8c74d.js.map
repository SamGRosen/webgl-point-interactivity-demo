{"mappings":"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","sources":["./node_modules/kdbush/src/sort.js","./node_modules/kdbush/src/range.js","./node_modules/kdbush/src/within.js","./node_modules/kdbush/src/index.js","./node_modules/supercluster/index.js","./node_modules/@turf/helpers/dist/es/index.js","./node_modules/@turf/invariant/dist/es/index.js","./node_modules/@turf/boolean-point-in-polygon/dist/es/index.js","./node_modules/@turf/clean-coords/dist/es/index.js","./node_modules/@turf/clone/dist/es/index.js","./node_modules/@turf/meta/dist/es/index.js","./node_modules/@turf/simplify/dist/es/index.js","./src/epiviz.gl/data-processor.js","./src/epiviz.gl/data-processor-worker.js"],"sourcesContent":["\nexport default function sortKD(ids, coords, nodeSize, left, right, depth) {\n    if (right - left <= nodeSize) return;\n\n    const m = (left + right) >> 1;\n\n    select(ids, coords, m, left, right, depth % 2);\n\n    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);\n    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);\n}\n\nfunction select(ids, coords, k, left, right, inc) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, inc);\n        }\n\n        const t = coords[2 * k + inc];\n        let i = left;\n        let j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + inc] < t) i++;\n            while (coords[2 * j + inc] > t) j--;\n        }\n\n        if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);\n        else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n","\nexport default function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    let x, y;\n\n    while (stack.length) {\n        const axis = stack.pop();\n        const right = stack.pop();\n        const left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (let i = left; i <= right; i++) {\n                x = coords[2 * i];\n                y = coords[2 * i + 1];\n                if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        const m = Math.floor((left + right) / 2);\n\n        x = coords[2 * m];\n        y = coords[2 * m + 1];\n\n        if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\n\n        const nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? minX <= x : minY <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? maxX >= x : maxY >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n","\nexport default function within(ids, coords, qx, qy, r, nodeSize) {\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    const r2 = r * r;\n\n    while (stack.length) {\n        const axis = stack.pop();\n        const right = stack.pop();\n        const left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (let i = left; i <= right; i++) {\n                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        const m = Math.floor((left + right) / 2);\n\n        const x = coords[2 * m];\n        const y = coords[2 * m + 1];\n\n        if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\n\n        const nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? qx - r <= x : qy - r <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? qx + r >= x : qy + r >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n\nfunction sqDist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n","\nimport sort from './sort';\nimport range from './range';\nimport within from './within';\n\nconst defaultGetX = p => p[0];\nconst defaultGetY = p => p[1];\n\nexport default class KDBush {\n    constructor(points, getX = defaultGetX, getY = defaultGetY, nodeSize = 64, ArrayType = Float64Array) {\n        this.nodeSize = nodeSize;\n        this.points = points;\n\n        const IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;\n\n        const ids = this.ids = new IndexArrayType(points.length);\n        const coords = this.coords = new ArrayType(points.length * 2);\n\n        for (let i = 0; i < points.length; i++) {\n            ids[i] = i;\n            coords[2 * i] = getX(points[i]);\n            coords[2 * i + 1] = getY(points[i]);\n        }\n\n        sort(ids, coords, nodeSize, 0, ids.length - 1, 0);\n    }\n\n    range(minX, minY, maxX, maxY) {\n        return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);\n    }\n\n    within(x, y, r) {\n        return within(this.ids, this.coords, x, y, r, this.nodeSize);\n    }\n}\n","\nimport KDBush from 'kdbush';\n\nconst defaultOptions = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    minPoints: 2, // minimum points to form a cluster\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: props => props // props => ({sum: props.my_value})\n};\n\nconst fround = Math.fround || (tmp => ((x) => { tmp[0] = +x; return tmp[0]; }))(new Float32Array(1));\n\nexport default class Supercluster {\n    constructor(options) {\n        this.options = extend(Object.create(defaultOptions), options);\n        this.trees = new Array(this.options.maxZoom + 1);\n    }\n\n    load(points) {\n        const {log, minZoom, maxZoom, nodeSize} = this.options;\n\n        if (log) console.time('total time');\n\n        const timerId = `prepare ${  points.length  } points`;\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        let clusters = [];\n        for (let i = 0; i < points.length; i++) {\n            if (!points[i].geometry) continue;\n            clusters.push(createPointCluster(points[i], i));\n        }\n        this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (let z = maxZoom; z >= minZoom; z--) {\n            const now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            clusters = this._cluster(clusters, z);\n            this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    }\n\n    getClusters(bbox, zoom) {\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        const tree = this.trees[this._limitZoom(zoom)];\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        const clusters = [];\n        for (const id of ids) {\n            const c = tree.points[id];\n            clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n        }\n        return clusters;\n    }\n\n    getChildren(clusterId) {\n        const originId = this._getOriginId(clusterId);\n        const originZoom = this._getOriginZoom(clusterId);\n        const errorMsg = 'No cluster with the specified id.';\n\n        const index = this.trees[originZoom];\n        if (!index) throw new Error(errorMsg);\n\n        const origin = index.points[originId];\n        if (!origin) throw new Error(errorMsg);\n\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        const ids = index.within(origin.x, origin.y, r);\n        const children = [];\n        for (const id of ids) {\n            const c = index.points[id];\n            if (c.parentId === clusterId) {\n                children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    }\n\n    getLeaves(clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        const leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    }\n\n    getTile(z, x, y) {\n        const tree = this.trees[this._limitZoom(z)];\n        const z2 = Math.pow(2, z);\n        const {extent, radius} = this.options;\n        const p = radius / extent;\n        const top = (y - p) / z2;\n        const bottom = (y + 1 + p) / z2;\n\n        const tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.points, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.points, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.points, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    }\n\n    getClusterExpansionZoom(clusterId) {\n        let expansionZoom = this._getOriginZoom(clusterId) - 1;\n        while (expansionZoom <= this.options.maxZoom) {\n            const children = this.getChildren(clusterId);\n            expansionZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return expansionZoom;\n    }\n\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\n        const children = this.getChildren(clusterId);\n\n        for (const child of children) {\n            const props = child.properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(child);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    }\n\n    _addTileFeatures(ids, points, x, y, z2, tile) {\n        for (const i of ids) {\n            const c = points[i];\n            const isCluster = c.numPoints;\n\n            let tags, px, py;\n            if (isCluster) {\n                tags = getClusterProperties(c);\n                px = c.x;\n                py = c.y;\n            } else {\n                const p = this.points[c.index];\n                tags = p.properties;\n                px = lngX(p.geometry.coordinates[0]);\n                py = latY(p.geometry.coordinates[1]);\n            }\n\n            const f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (px * z2 - x)),\n                    Math.round(this.options.extent * (py * z2 - y))\n                ]],\n                tags\n            };\n\n            // assign id\n            let id;\n            if (isCluster) {\n                id = c.id;\n            } else if (this.options.generateId) {\n                // optionally generate id\n                id = c.index;\n            } else if (this.points[c.index].id) {\n                // keep id if already assigned\n                id = this.points[c.index].id;\n            }\n\n            if (id !== undefined) f.id = id;\n\n            tile.features.push(f);\n        }\n    }\n\n    _limitZoom(z) {\n        return Math.max(this.options.minZoom, Math.min(+z, this.options.maxZoom + 1));\n    }\n\n    _cluster(points, zoom) {\n        const clusters = [];\n        const {radius, extent, reduce, minPoints} = this.options;\n        const r = radius / (extent * Math.pow(2, zoom));\n\n        // loop through each point\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            // if we've already visited the point at this zoom level, skip it\n            if (p.zoom <= zoom) continue;\n            p.zoom = zoom;\n\n            // find all nearby points\n            const tree = this.trees[zoom + 1];\n            const neighborIds = tree.within(p.x, p.y, r);\n\n            const numPointsOrigin = p.numPoints || 1;\n            let numPoints = numPointsOrigin;\n\n            // count the number of points in a potential cluster\n            for (const neighborId of neighborIds) {\n                const b = tree.points[neighborId];\n                // filter out neighbors that are already processed\n                if (b.zoom > zoom) numPoints += b.numPoints || 1;\n            }\n\n            if (numPoints >= minPoints) { // enough points to form a cluster\n                let wx = p.x * numPointsOrigin;\n                let wy = p.y * numPointsOrigin;\n\n                let clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null;\n\n                // encode both zoom and point index on which the cluster originated -- offset by total length of features\n                const id = (i << 5) + (zoom + 1) + this.points.length;\n\n                for (const neighborId of neighborIds) {\n                    const b = tree.points[neighborId];\n\n                    if (b.zoom <= zoom) continue;\n                    b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n                    const numPoints2 = b.numPoints || 1;\n                    wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\n                    wy += b.y * numPoints2;\n\n                    b.parentId = id;\n\n                    if (reduce) {\n                        if (!clusterProperties) clusterProperties = this._map(p, true);\n                        reduce(clusterProperties, this._map(b));\n                    }\n                }\n\n                p.parentId = id;\n                clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n\n            } else { // left points as unclustered\n                clusters.push(p);\n\n                if (numPoints > 1) {\n                    for (const neighborId of neighborIds) {\n                        const b = tree.points[neighborId];\n                        if (b.zoom <= zoom) continue;\n                        b.zoom = zoom;\n                        clusters.push(b);\n                    }\n                }\n            }\n        }\n\n        return clusters;\n    }\n\n    // get index of the point from which the cluster originated\n    _getOriginId(clusterId) {\n        return (clusterId - this.points.length) >> 5;\n    }\n\n    // get zoom of the point from which the cluster originated\n    _getOriginZoom(clusterId) {\n        return (clusterId - this.points.length) % 32;\n    }\n\n    _map(point, clone) {\n        if (point.numPoints) {\n            return clone ? extend({}, point.properties) : point.properties;\n        }\n        const original = this.points[point.index].properties;\n        const result = this.options.map(original);\n        return clone && result === original ? extend({}, result) : result;\n    }\n}\n\nfunction createCluster(x, y, id, numPoints, properties) {\n    return {\n        x: fround(x), // weighted cluster center; round for consistency with Float32Array index\n        y: fround(y),\n        zoom: Infinity, // the last zoom the cluster was processed at\n        id, // encodes index of the first child of the cluster and its zoom level\n        parentId: -1, // parent cluster id\n        numPoints,\n        properties\n    };\n}\n\nfunction createPointCluster(p, id) {\n    const [x, y] = p.geometry.coordinates;\n    return {\n        x: fround(lngX(x)), // projected point coordinates\n        y: fround(latY(y)),\n        zoom: Infinity, // the last zoom the point was processed at\n        index: id, // index of the source feature in the original input array,\n        parentId: -1 // parent cluster id\n    };\n}\n\nfunction getClusterJSON(cluster) {\n    return {\n        type: 'Feature',\n        id: cluster.id,\n        properties: getClusterProperties(cluster),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\n        }\n    };\n}\n\nfunction getClusterProperties(cluster) {\n    const count = cluster.numPoints;\n    const abbrev =\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\n    return extend(extend({}, cluster.properties), {\n        cluster: true,\n        cluster_id: cluster.id,\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    const sin = Math.sin(lat * Math.PI / 180);\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    const y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n    for (const id in src) dest[id] = src[id];\n    return dest;\n}\n\nfunction getX(p) {\n    return p.x;\n}\nfunction getY(p) {\n    return p.y;\n}\n","/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n","import { getCoord, getGeom } from \"@turf/invariant\";\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point\n * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Coord} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if\n * the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\nexport default function booleanPointInPolygon(point, polygon, options) {\n    if (options === void 0) { options = {}; }\n    // validation\n    if (!point) {\n        throw new Error(\"point is required\");\n    }\n    if (!polygon) {\n        throw new Error(\"polygon is required\");\n    }\n    var pt = getCoord(point);\n    var geom = getGeom(polygon);\n    var type = geom.type;\n    var bbox = polygon.bbox;\n    var polys = geom.coordinates;\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) {\n        return false;\n    }\n    // normalize to multipolygon\n    if (type === \"Polygon\") {\n        polys = [polys];\n    }\n    var insidePoly = false;\n    for (var i = 0; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) {\n                insidePoly = true;\n            }\n        }\n    }\n    return insidePoly;\n}\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] &&\n        ring[0][1] === ring[ring.length - 1][1]) {\n        ring = ring.slice(0, ring.length - 1);\n    }\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0];\n        var yi = ring[i][1];\n        var xj = ring[j][0];\n        var yj = ring[j][1];\n        var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 &&\n            (xi - pt[0]) * (xj - pt[0]) <= 0 &&\n            (yi - pt[1]) * (yj - pt[1]) <= 0;\n        if (onBoundary) {\n            return !ignoreBoundary;\n        }\n        var intersect = yi > pt[1] !== yj > pt[1] &&\n            pt[0] < ((xj - xi) * (pt[1] - yi)) / (yj - yi) + xi;\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\n/**\n * inBBox\n *\n * @private\n * @param {Position} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return (bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1]);\n}\n","import { feature } from \"@turf/helpers\";\nimport { getCoords, getType } from \"@turf/invariant\";\n// To-Do => Improve Typescript GeoJSON handling\n/**\n * Removes redundant coordinates from any GeoJSON Geometry.\n *\n * @name cleanCoords\n * @param {Geometry|Feature} geojson Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated\n * @returns {Geometry|Feature} the cleaned input Feature/Geometry\n * @example\n * var line = turf.lineString([[0, 0], [0, 2], [0, 5], [0, 8], [0, 8], [0, 10]]);\n * var multiPoint = turf.multiPoint([[0, 0], [0, 0], [2, 2]]);\n *\n * turf.cleanCoords(line).geometry.coordinates;\n * //= [[0, 0], [0, 10]]\n *\n * turf.cleanCoords(multiPoint).geometry.coordinates;\n * //= [[0, 0], [2, 2]]\n */\nfunction cleanCoords(geojson, options) {\n    if (options === void 0) { options = {}; }\n    // Backwards compatible with v4.0\n    var mutate = typeof options === \"object\" ? options.mutate : options;\n    if (!geojson)\n        throw new Error(\"geojson is required\");\n    var type = getType(geojson);\n    // Store new \"clean\" points in this Array\n    var newCoords = [];\n    switch (type) {\n        case \"LineString\":\n            newCoords = cleanLine(geojson);\n            break;\n        case \"MultiLineString\":\n        case \"Polygon\":\n            getCoords(geojson).forEach(function (line) {\n                newCoords.push(cleanLine(line));\n            });\n            break;\n        case \"MultiPolygon\":\n            getCoords(geojson).forEach(function (polygons) {\n                var polyPoints = [];\n                polygons.forEach(function (ring) {\n                    polyPoints.push(cleanLine(ring));\n                });\n                newCoords.push(polyPoints);\n            });\n            break;\n        case \"Point\":\n            return geojson;\n        case \"MultiPoint\":\n            var existing = {};\n            getCoords(geojson).forEach(function (coord) {\n                var key = coord.join(\"-\");\n                if (!existing.hasOwnProperty(key)) {\n                    newCoords.push(coord);\n                    existing[key] = true;\n                }\n            });\n            break;\n        default:\n            throw new Error(type + \" geometry not supported\");\n    }\n    // Support input mutation\n    if (geojson.coordinates) {\n        if (mutate === true) {\n            geojson.coordinates = newCoords;\n            return geojson;\n        }\n        return { type: type, coordinates: newCoords };\n    }\n    else {\n        if (mutate === true) {\n            geojson.geometry.coordinates = newCoords;\n            return geojson;\n        }\n        return feature({ type: type, coordinates: newCoords }, geojson.properties, {\n            bbox: geojson.bbox,\n            id: geojson.id,\n        });\n    }\n}\n/**\n * Clean Coords\n *\n * @private\n * @param {Array<number>|LineString} line Line\n * @returns {Array<number>} Cleaned coordinates\n */\nfunction cleanLine(line) {\n    var points = getCoords(line);\n    // handle \"clean\" segment\n    if (points.length === 2 && !equals(points[0], points[1]))\n        return points;\n    var newPoints = [];\n    var secondToLast = points.length - 1;\n    var newPointsLength = newPoints.length;\n    newPoints.push(points[0]);\n    for (var i = 1; i < secondToLast; i++) {\n        var prevAddedPoint = newPoints[newPoints.length - 1];\n        if (points[i][0] === prevAddedPoint[0] &&\n            points[i][1] === prevAddedPoint[1])\n            continue;\n        else {\n            newPoints.push(points[i]);\n            newPointsLength = newPoints.length;\n            if (newPointsLength > 2) {\n                if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2]))\n                    newPoints.splice(newPoints.length - 2, 1);\n            }\n        }\n    }\n    newPoints.push(points[points.length - 1]);\n    newPointsLength = newPoints.length;\n    if (equals(points[0], points[points.length - 1]) && newPointsLength < 4)\n        throw new Error(\"invalid polygon\");\n    if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2]))\n        newPoints.splice(newPoints.length - 2, 1);\n    return newPoints;\n}\n/**\n * Compares two points and returns if they are equals\n *\n * @private\n * @param {Position} pt1 point\n * @param {Position} pt2 point\n * @returns {boolean} true if they are equals\n */\nfunction equals(pt1, pt2) {\n    return pt1[0] === pt2[0] && pt1[1] === pt2[1];\n}\n/**\n * Returns if `point` is on the segment between `start` and `end`.\n * Borrowed from `@turf/boolean-point-on-line` to speed up the evaluation (instead of using the module as dependency)\n *\n * @private\n * @param {Position} start coord pair of start of line\n * @param {Position} end coord pair of end of line\n * @param {Position} point coord pair of point to check\n * @returns {boolean} true/false\n */\nfunction isPointOnLineSegment(start, end, point) {\n    var x = point[0], y = point[1];\n    var startX = start[0], startY = start[1];\n    var endX = end[0], endY = end[1];\n    var dxc = x - startX;\n    var dyc = y - startY;\n    var dxl = endX - startX;\n    var dyl = endY - startY;\n    var cross = dxc * dyl - dyc * dxl;\n    if (cross !== 0)\n        return false;\n    else if (Math.abs(dxl) >= Math.abs(dyl))\n        return dxl > 0 ? startX <= x && x <= endX : endX <= x && x <= startX;\n    else\n        return dyl > 0 ? startY <= y && y <= endY : endY <= y && y <= startY;\n}\nexport default cleanCoords;\n","/**\n * Returns a cloned copy of the passed GeoJSON Object, including possible 'Foreign Members'.\n * ~3-5x faster than the common JSON.parse + JSON.stringify combo method.\n *\n * @name clone\n * @param {GeoJSON} geojson GeoJSON Object\n * @returns {GeoJSON} cloned GeoJSON Object\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]], {color: 'red'});\n *\n * var lineCloned = turf.clone(line);\n */\nfunction clone(geojson) {\n    if (!geojson) {\n        throw new Error(\"geojson is required\");\n    }\n    switch (geojson.type) {\n        case \"Feature\":\n            return cloneFeature(geojson);\n        case \"FeatureCollection\":\n            return cloneFeatureCollection(geojson);\n        case \"Point\":\n        case \"LineString\":\n        case \"Polygon\":\n        case \"MultiPoint\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\":\n        case \"GeometryCollection\":\n            return cloneGeometry(geojson);\n        default:\n            throw new Error(\"unknown GeoJSON type\");\n    }\n}\n/**\n * Clone Feature\n *\n * @private\n * @param {Feature<any>} geojson GeoJSON Feature\n * @returns {Feature<any>} cloned Feature\n */\nfunction cloneFeature(geojson) {\n    var cloned = { type: \"Feature\" };\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n            case \"type\":\n            case \"properties\":\n            case \"geometry\":\n                return;\n            default:\n                cloned[key] = geojson[key];\n        }\n    });\n    // Add properties & geometry last\n    cloned.properties = cloneProperties(geojson.properties);\n    cloned.geometry = cloneGeometry(geojson.geometry);\n    return cloned;\n}\n/**\n * Clone Properties\n *\n * @private\n * @param {Object} properties GeoJSON Properties\n * @returns {Object} cloned Properties\n */\nfunction cloneProperties(properties) {\n    var cloned = {};\n    if (!properties) {\n        return cloned;\n    }\n    Object.keys(properties).forEach(function (key) {\n        var value = properties[key];\n        if (typeof value === \"object\") {\n            if (value === null) {\n                // handle null\n                cloned[key] = null;\n            }\n            else if (Array.isArray(value)) {\n                // handle Array\n                cloned[key] = value.map(function (item) {\n                    return item;\n                });\n            }\n            else {\n                // handle generic Object\n                cloned[key] = cloneProperties(value);\n            }\n        }\n        else {\n            cloned[key] = value;\n        }\n    });\n    return cloned;\n}\n/**\n * Clone Feature Collection\n *\n * @private\n * @param {FeatureCollection<any>} geojson GeoJSON Feature Collection\n * @returns {FeatureCollection<any>} cloned Feature Collection\n */\nfunction cloneFeatureCollection(geojson) {\n    var cloned = { type: \"FeatureCollection\" };\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n            case \"type\":\n            case \"features\":\n                return;\n            default:\n                cloned[key] = geojson[key];\n        }\n    });\n    // Add features\n    cloned.features = geojson.features.map(function (feature) {\n        return cloneFeature(feature);\n    });\n    return cloned;\n}\n/**\n * Clone Geometry\n *\n * @private\n * @param {Geometry<any>} geometry GeoJSON Geometry\n * @returns {Geometry<any>} cloned Geometry\n */\nfunction cloneGeometry(geometry) {\n    var geom = { type: geometry.type };\n    if (geometry.bbox) {\n        geom.bbox = geometry.bbox;\n    }\n    if (geometry.type === \"GeometryCollection\") {\n        geom.geometries = geometry.geometries.map(function (g) {\n            return cloneGeometry(g);\n        });\n        return geom;\n    }\n    geom.coordinates = deepSlice(geometry.coordinates);\n    return geom;\n}\n/**\n * Deep Slice coordinates\n *\n * @private\n * @param {Coordinates} coords Coordinates\n * @returns {Coordinates} all coordinates sliced\n */\nfunction deepSlice(coords) {\n    var cloned = coords;\n    if (typeof cloned[0] !== \"object\") {\n        return cloned.slice();\n    }\n    return cloned.map(function (coord) {\n        return deepSlice(coord);\n    });\n}\nexport default clone;\n","import { feature, point, lineString, isObject } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature$$1.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature$$1.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature$$1,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = lineString(\n            [previousCoords, currentCoord],\n            feature$$1.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n    if (feature$$1.geometry === null) return;\n    var type = feature$$1.geometry.type;\n    var coords = feature$$1.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              lineString(coords[geometryIndex], feature$$1.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexport { coordEach, coordReduce, propEach, propReduce, featureEach, featureReduce, coordAll, geomEach, geomReduce, flattenEach, flattenReduce, segmentEach, segmentReduce, lineEach, lineReduce, findSegment, findPoint };\n","import cleanCoords from '@turf/clean-coords';\nimport clone from '@turf/clone';\nimport { geomEach } from '@turf/meta';\nimport { isObject } from '@turf/helpers';\n\n/*\n (c) 2013, Vladimir Agafonkin\n Simplify.js, a high-performance JS polyline simplification library\n mourner.github.io/simplify-js\n*/\n\n// to suit your point format, run search/replace for '.x' and '.y';\n// for 3D version, see 3d branch (configurability would draw significant performance overhead)\n\n// square distance between 2 points\nfunction getSqDist(p1, p2) {\n  var dx = p1.x - p2.x,\n    dy = p1.y - p2.y;\n\n  return dx * dx + dy * dy;\n}\n\n// square distance from a point to a segment\nfunction getSqSegDist(p, p1, p2) {\n  var x = p1.x,\n    y = p1.y,\n    dx = p2.x - x,\n    dy = p2.y - y;\n\n  if (dx !== 0 || dy !== 0) {\n    var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);\n\n    if (t > 1) {\n      x = p2.x;\n      y = p2.y;\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n\n  dx = p.x - x;\n  dy = p.y - y;\n\n  return dx * dx + dy * dy;\n}\n// rest of the code doesn't care about point format\n\n// basic distance-based simplification\nfunction simplifyRadialDist(points, sqTolerance) {\n  var prevPoint = points[0],\n    newPoints = [prevPoint],\n    point;\n\n  for (var i = 1, len = points.length; i < len; i++) {\n    point = points[i];\n\n    if (getSqDist(point, prevPoint) > sqTolerance) {\n      newPoints.push(point);\n      prevPoint = point;\n    }\n  }\n\n  if (prevPoint !== point) newPoints.push(point);\n\n  return newPoints;\n}\n\nfunction simplifyDPStep(points, first, last, sqTolerance, simplified) {\n  var maxSqDist = sqTolerance,\n    index;\n\n  for (var i = first + 1; i < last; i++) {\n    var sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n    if (sqDist > maxSqDist) {\n      index = i;\n      maxSqDist = sqDist;\n    }\n  }\n\n  if (maxSqDist > sqTolerance) {\n    if (index - first > 1)\n      simplifyDPStep(points, first, index, sqTolerance, simplified);\n    simplified.push(points[index]);\n    if (last - index > 1)\n      simplifyDPStep(points, index, last, sqTolerance, simplified);\n  }\n}\n\n// simplification using Ramer-Douglas-Peucker algorithm\nfunction simplifyDouglasPeucker(points, sqTolerance) {\n  var last = points.length - 1;\n\n  var simplified = [points[0]];\n  simplifyDPStep(points, 0, last, sqTolerance, simplified);\n  simplified.push(points[last]);\n\n  return simplified;\n}\n\n// both algorithms combined for awesome performance\nfunction simplify(points, tolerance, highestQuality) {\n  if (points.length <= 2) return points;\n\n  var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n\n  points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n  points = simplifyDouglasPeucker(points, sqTolerance);\n\n  return points;\n}\n\n/**\n * Takes a {@link GeoJSON} object and returns a simplified version. Internally uses\n * [simplify-js](http://mourner.github.io/simplify-js/) to perform simplification using the Ramer-Douglas-Peucker algorithm.\n *\n * @name simplify\n * @param {GeoJSON} geojson object to be simplified\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.tolerance=1] simplification tolerance\n * @param {boolean} [options.highQuality=false] whether or not to spend more time to create a higher-quality simplification with a different algorithm\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} a simplified GeoJSON\n * @example\n * var geojson = turf.polygon([[\n *   [-70.603637, -33.399918],\n *   [-70.614624, -33.395332],\n *   [-70.639343, -33.392466],\n *   [-70.659942, -33.394759],\n *   [-70.683975, -33.404504],\n *   [-70.697021, -33.419406],\n *   [-70.701141, -33.434306],\n *   [-70.700454, -33.446339],\n *   [-70.694274, -33.458369],\n *   [-70.682601, -33.465816],\n *   [-70.668869, -33.472117],\n *   [-70.646209, -33.473835],\n *   [-70.624923, -33.472117],\n *   [-70.609817, -33.468107],\n *   [-70.595397, -33.458369],\n *   [-70.587158, -33.442901],\n *   [-70.587158, -33.426283],\n *   [-70.590591, -33.414248],\n *   [-70.594711, -33.406224],\n *   [-70.603637, -33.399918]\n * ]]);\n * var options = {tolerance: 0.01, highQuality: false};\n * var simplified = turf.simplify(geojson, options);\n *\n * //addToMap\n * var addToMap = [geojson, simplified]\n */\nfunction simplify$1(geojson, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var tolerance = options.tolerance !== undefined ? options.tolerance : 1;\n  var highQuality = options.highQuality || false;\n  var mutate = options.mutate || false;\n\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (tolerance && tolerance < 0) throw new Error(\"invalid tolerance\");\n\n  // Clone geojson to avoid side effects\n  if (mutate !== true) geojson = clone(geojson);\n\n  geomEach(geojson, function (geom) {\n    simplifyGeom(geom, tolerance, highQuality);\n  });\n  return geojson;\n}\n\n/**\n * Simplifies a feature's coordinates\n *\n * @private\n * @param {Geometry} geometry to be simplified\n * @param {number} [tolerance=1] simplification tolerance\n * @param {boolean} [highQuality=false] whether or not to spend more time to create a higher-quality simplification with a different algorithm\n * @returns {Geometry} output\n */\nfunction simplifyGeom(geometry, tolerance, highQuality) {\n  var type = geometry.type;\n\n  // \"unsimplyfiable\" geometry types\n  if (type === \"Point\" || type === \"MultiPoint\") return geometry;\n\n  // Remove any extra coordinates\n  cleanCoords(geometry, true);\n\n  var coordinates = geometry.coordinates;\n  switch (type) {\n    case \"LineString\":\n      geometry[\"coordinates\"] = simplifyLine(\n        coordinates,\n        tolerance,\n        highQuality\n      );\n      break;\n    case \"MultiLineString\":\n      geometry[\"coordinates\"] = coordinates.map(function (lines) {\n        return simplifyLine(lines, tolerance, highQuality);\n      });\n      break;\n    case \"Polygon\":\n      geometry[\"coordinates\"] = simplifyPolygon(\n        coordinates,\n        tolerance,\n        highQuality\n      );\n      break;\n    case \"MultiPolygon\":\n      geometry[\"coordinates\"] = coordinates.map(function (rings) {\n        return simplifyPolygon(rings, tolerance, highQuality);\n      });\n  }\n  return geometry;\n}\n\n/**\n * Simplifies the coordinates of a LineString with simplify-js\n *\n * @private\n * @param {Array<number>} coordinates to be processed\n * @param {number} tolerance simplification tolerance\n * @param {boolean} highQuality whether or not to spend more time to create a higher-quality\n * @returns {Array<Array<number>>} simplified coords\n */\nfunction simplifyLine(coordinates, tolerance, highQuality) {\n  return simplify(\n    coordinates.map(function (coord) {\n      return { x: coord[0], y: coord[1], z: coord[2] };\n    }),\n    tolerance,\n    highQuality\n  ).map(function (coords) {\n    return coords.z ? [coords.x, coords.y, coords.z] : [coords.x, coords.y];\n  });\n}\n\n/**\n * Simplifies the coordinates of a Polygon with simplify-js\n *\n * @private\n * @param {Array<number>} coordinates to be processed\n * @param {number} tolerance simplification tolerance\n * @param {boolean} highQuality whether or not to spend more time to create a higher-quality\n * @returns {Array<Array<Array<number>>>} simplified coords\n */\nfunction simplifyPolygon(coordinates, tolerance, highQuality) {\n  return coordinates.map(function (ring) {\n    var pts = ring.map(function (coord) {\n      return { x: coord[0], y: coord[1] };\n    });\n    if (pts.length < 4) {\n      throw new Error(\"invalid polygon\");\n    }\n    var simpleRing = simplify(pts, tolerance, highQuality).map(function (\n      coords\n    ) {\n      return [coords.x, coords.y];\n    });\n    //remove 1 percent of tolerance until enough points to make a triangle\n    while (!checkValidity(simpleRing)) {\n      tolerance -= tolerance * 0.01;\n      simpleRing = simplify(pts, tolerance, highQuality).map(function (\n        coords\n      ) {\n        return [coords.x, coords.y];\n      });\n    }\n    if (\n      simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0] ||\n      simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1]\n    ) {\n      simpleRing.push(simpleRing[0]);\n    }\n    return simpleRing;\n  });\n}\n\n/**\n * Returns true if ring has at least 3 coordinates and its first coordinate is the same as its last\n *\n * @private\n * @param {Array<number>} ring coordinates to be checked\n * @returns {boolean} true if valid\n */\nfunction checkValidity(ring) {\n  if (ring.length < 3) return false;\n  //if the last point is the same as the first, it's not a triangle\n  return !(\n    ring.length === 3 &&\n    ring[2][0] === ring[0][0] &&\n    ring[2][1] === ring[0][1]\n  );\n}\n\nexport default simplify$1;\n","import SchemaProcessor from \"./schema-processor\";\n\nimport Supercluster from \"supercluster\";\nimport booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport { polygon } from \"@turf/helpers\";\nimport simplify from \"@turf/simplify\";\nimport { GenomeScale } from \"./genome-sizes\";\n\nclass DataProcessor {\n  /**\n   * A class meant to handle processing of data used in the scatterplot.\n   *\n   * ** Can currently only handle data in a [-180,180] x [-90, 90] range due\n   * to use of {@link Supercluster}. May need to switch to KDBush at some point.\n   *\n   * @param {Array} data the processor is meant to handle and index\n   */\n  constructor(schema) {\n    this.schema = this.index = new Supercluster();\n\n    console.log(\"Loading data...\");\n\n    new SchemaProcessor(schema, this.indexData.bind(this));\n  }\n\n  /**\n   * Callback function that occurs after the schema processor has loaded the appropriate data\n   *\n   * @param {SchemaProcessor} schemaHelper that is built in the constructor\n   */\n  indexData(schemaHelper) {\n    this.points = [];\n    let modifyGeometry;\n\n    // If we are using genome scales, we need to map the coordinates correctly\n    // We build mapping functions based on what needs to occur for each data\n    // point in order to avoid lots of checks in the potentially very long\n    // data loop.\n    if (schemaHelper.xScale instanceof GenomeScale) {\n      modifyGeometry = (point) => {\n        point.geometry.coordinates[0] =\n          schemaHelper.xScale.toClipSpaceFromParts(\n            point.geometry.coordinates[0][0],\n            point.geometry.coordinates[0][1]\n          );\n      };\n    }\n\n    if (schemaHelper.yScale instanceof GenomeScale) {\n      // This is a way to check if x is also a genome scale, so we don't\n      // include instanceof checks in the data loop\n      if (modifyGeometry) {\n        // x dimension is also a genome scale\n        (point) => {\n          point.geometry.coordinates = [\n            schemaHelper.xScale.toClipSpaceFromParts(\n              point.geometry.coordinates[0][0],\n              point.geometry.coordinates[0][1]\n            ),\n            schemaHelper.yScale.toClipSpaceFromParts(\n              point.geometry.coordinates[0][0],\n              point.geometry.coordinates[0][1]\n            ),\n          ];\n        };\n      } else {\n        modifyGeometry = (point) => {\n          point.geometry.coordinates[1] =\n            schemaHelper.yScale.toClipSpaceFromParts(\n              point.geometry.coordinates[0][0],\n              point.geometry.coordinates[0][1]\n            );\n        };\n      }\n    }\n\n    console.log(\"Reading data...\");\n\n    // Process the global data in the schema processor\n    if (schemaHelper.data) {\n      for (let track of schemaHelper.tracks) {\n        if (!track.hasOwnData) {\n          let currentPoint = track.getNextDataPoint();\n          while (currentPoint) {\n            if (modifyGeometry) {\n              // only call if we need to\n              modifyGeometry(currentPoint);\n            }\n            this.points.push(currentPoint);\n            currentPoint = track.getNextDataPoint();\n          }\n          break;\n        }\n      }\n    }\n\n    // Process the data that is local to each track\n    schemaHelper.tracks\n      .filter((track) => track.hasOwnData)\n      .forEach((track) => {\n        let currentPoint = track.getNextDataPoint();\n        while (currentPoint) {\n          if (modifyGeometry) {\n            modifyGeometry(currentPoint);\n          }\n          this.points.push(currentPoint);\n          currentPoint = track.getNextDataPoint();\n        }\n      });\n\n    console.log(\"Indexing data...\");\n    this.index.load(this.points);\n\n    console.log(\"Data processing complete.\");\n  }\n\n  /**\n   * Find the closest point in the data to a given point. Only finds point if it is\n   * sufficiently close.\n   *\n   * @param {Array} point of two floats to find closest point to\n   * @param {Integer} zoom to pass to supercluster\n   * @returns closest point or undefined\n   */\n  getClosestPoint(point, zoom = 16) {\n    const candidatePoints = this.index.getClusters(\n      [point[0] - 0.01, point[1] - 0.01, point[0] + 0.01, point[1] + 0.01],\n      zoom\n    );\n\n    let closestPoint;\n    let distanceToClosestPoint;\n    for (const candidate of candidatePoints) {\n      const dist =\n        (candidate.geometry.coordinates[0] - point[0]) ** 2 +\n        (candidate.geometry.coordinates[1] - point[1]) ** 2;\n      if (!closestPoint || dist < distanceToClosestPoint) {\n        closestPoint = candidate;\n        distanceToClosestPoint = dist;\n      }\n    }\n\n    return closestPoint;\n  }\n\n  /**\n   * Get points within a bounding box.\n   *\n   * @param {Array} points Bounding rectangle in the format of [x1, y1, x2, y2]\n   * @param {Integer} zoom to pass to supercluster\n   * @returns points in bounding box\n   */\n  selectBox(points, zoom = 16) {\n    const smallerX = Math.min(points[0], points[2]);\n    const smallerY = Math.min(points[1], points[3]);\n    const largerX = Math.max(points[0], points[2]);\n    const largerY = Math.max(points[1], points[3]);\n\n    return this.index.getClusters([smallerX, smallerY, largerX, largerY], zoom);\n  }\n\n  /**\n   * Select points inside a given polygon. Simplify polygon with {@link @turf/simplify}\n   * which may cause precision issues with very complex polygons. Uses {@link turf}\n   * to determine what points are in polygon.\n   *\n   * @param {Array} points of a polygon to select points format: [x1,y1,x2,y2,x3,y3,...]\n   * @param {Integer} zoom to pass to supercluster\n   * @returns points inside lasso\n   */\n  selectLasso(points, zoom = 16) {\n    let smallestX = Number.POSITIVE_INFINITY;\n    let largestX = Number.NEGATIVE_INFINITY;\n    let smallestY = Number.POSITIVE_INFINITY;\n    let largestY = Number.NEGATIVE_INFINITY;\n    const polygonPoints = [];\n    for (let i = 0; i < points.length; i += 2) {\n      if (points[i] < smallestX) smallestX = points[i];\n      if (points[i] > largestX) largestX = points[i];\n      if (points[i + 1] < smallestY) smallestY = points[i + 1];\n      if (points[i + 1] > largestY) largestY = points[i + 1];\n      polygonPoints.push([points[i], points[i + 1]]);\n    }\n\n    polygonPoints.push([...polygonPoints[0]]); // First and last must be same position\n\n    const candidatePoints = this.index.getClusters(\n      [smallestX, smallestY, largestX, largestY],\n      zoom\n    );\n\n    const boundingPolygon = polygon([polygonPoints]);\n\n    const simplifiedBoundingPolygon = simplify(boundingPolygon, {\n      tolerance: 0.01,\n      highQuality: false,\n    });\n\n    return candidatePoints.filter((point) => {\n      return booleanPointInPolygon(\n        point.geometry.coordinates,\n        simplifiedBoundingPolygon\n      );\n    });\n  }\n}\n\nexport default DataProcessor;\n","/**\n * The data processor worker is meant to be an interface between the main thread\n * containing the {@link WebGLVis} a {@link DataProcessor}. It's main purpose\n * is to receive messages from the WebGLVis, call the appropriate method of\n * the DataProcessor, then post a message of the results of the method back to\n * the WebGLVis.\n */\n\nimport DataProcessor from \"./data-processor\";\n\nself.onmessage = (message) => {\n  switch (message.data.type) {\n    case \"init\":\n      self.processor = new DataProcessor(message.data.schema);\n      break;\n    case \"selectBox\":\n      postMessage({\n        type: message.data.type,\n        selection: self.processor.selectBox(message.data.points),\n        bounds: message.data.points,\n      });\n      break;\n    case \"selectLasso\":\n      postMessage({\n        type: message.data.type,\n        selection: self.processor.selectLasso(message.data.points),\n        bounds: message.data.points,\n      });\n      break;\n    case \"getClosestPoint\":\n      postMessage({\n        type: message.data.type,\n        point: self.processor.getClosestPoint(message.data.point),\n      });\n      break;\n    default:\n      console.error(`Received unknown message type: ${message.type}`);\n  }\n};\n"],"names":["ids","coords","nodeSize","left","right","depth","m","$14e64092bb8e46d2258aa0c58e5c08ac$var$select","$14e64092bb8e46d2258aa0c58e5c08ac$export$default","k","inc","n","z","Math","log","s","exp","sd","sqrt","newLeft","max","floor","newRight","min","t","i","j","$14e64092bb8e46d2258aa0c58e5c08ac$var$swapItem","$14e64092bb8e46d2258aa0c58e5c08ac$var$swap","arr","tmp","minX","minY","maxX","maxY","stack","length","result","x","y","axis","pop","push","nextAxis","qx","qy","r","r2","$1033f4c4dea9b488065b6eddb394f033$var$sqDist","ax","ay","bx","by","dx","dy","$ec3a0e7135bf1313da05c68a69420c29$var$defaultGetX","p","$ec3a0e7135bf1313da05c68a69420c29$var$defaultGetY","constructor","points","getX","getY","ArrayType","Float64Array","IndexArrayType","Uint16Array","Uint32Array","range","within","$cf9bb3333627547726792c50f5fb3c08$var$defaultOptions","minZoom","maxZoom","minPoints","radius","extent","generateId","reduce","map","props","$cf9bb3333627547726792c50f5fb3c08$var$fround","fround","Float32Array","options","$cf9bb3333627547726792c50f5fb3c08$var$extend","Object","create","trees","Array","load","console","time","timerId","clusters","geometry","$cf9bb3333627547726792c50f5fb3c08$var$createPointCluster","$cf9bb3333627547726792c50f5fb3c08$var$getX","$cf9bb3333627547726792c50f5fb3c08$var$getY","timeEnd","now","Date","_cluster","getClusters","bbox","zoom","minLng","minLat","maxLng","maxLat","easternHem","westernHem","concat","tree","_limitZoom","$cf9bb3333627547726792c50f5fb3c08$var$lngX","$cf9bb3333627547726792c50f5fb3c08$var$latY","id","c","numPoints","$cf9bb3333627547726792c50f5fb3c08$var$getClusterJSON","index","getChildren","clusterId","originId","_getOriginId","originZoom","_getOriginZoom","errorMsg","Error","origin","pow","children","parentId","getLeaves","limit","offset","leaves","_appendLeaves","getTile","z2","top","bottom","tile","features","_addTileFeatures","getClusterExpansionZoom","expansionZoom","properties","cluster_id","skipped","child","cluster","point_count","isCluster","tags","px","py","$cf9bb3333627547726792c50f5fb3c08$var$getClusterProperties","coordinates","f","type","round","undefined","neighborIds","numPointsOrigin","neighborId","b","wx","wy","clusterProperties","_map","numPoints2","$cf9bb3333627547726792c50f5fb3c08$var$createCluster","point","clone","original","Infinity","$cf9bb3333627547726792c50f5fb3c08$var$xLng","$cf9bb3333627547726792c50f5fb3c08$var$yLat","count","abbrev","point_count_abbreviated","lng","lat","sin","PI","y2","atan","dest","src","$362d22883e0fd86686aa42c664ee2ee2$export$earthRadius","$362d22883e0fd86686aa42c664ee2ee2$export$factors","centimeters","centimetres","degrees","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","radians","yards","$362d22883e0fd86686aa42c664ee2ee2$export$areaFactors","acres","hectares","geom","feat","isArray","$362d22883e0fd86686aa42c664ee2ee2$export$isNumber","$362d22883e0fd86686aa42c664ee2ee2$export$feature","_i","coordinates_1","ring","fc","units","factor","distance","num","isNaN","input","coord","$c2991e57ce450f3b8cf95c6853e7a8c7$export$containsNumber","geojson","_name","polygon","pt","polys","$f99903ca6b6ebae475a2ceb9985c2665$var$inBBox","insidePoly","$f99903ca6b6ebae475a2ceb9985c2665$var$inRing","ignoreBoundary","inHole","isInside","slice","xi","yi","xj","yj","onBoundary","intersect","mutate","newCoords","$d16b20bb8256ea97e35dad84d8331884$var$cleanLine","forEach","line","polygons","polyPoints","existing","key","join","hasOwnProperty","$d16b20bb8256ea97e35dad84d8331884$var$equals","newPoints","secondToLast","newPointsLength","prevAddedPoint","$d16b20bb8256ea97e35dad84d8331884$var$isPointOnLineSegment","splice","pt1","pt2","start","end","startX","startY","endX","endY","dxc","dyc","dxl","dyl","cross","abs","$d96c902724926d7517e39719852e5262$var$cloneFeature","$d96c902724926d7517e39719852e5262$var$cloneFeatureCollection","$d96c902724926d7517e39719852e5262$var$cloneGeometry","cloned","keys","$d96c902724926d7517e39719852e5262$var$cloneProperties","value","item","feature","geometries","g","$d96c902724926d7517e39719852e5262$var$deepSlice","callback","excludeWrapCoord","l","stopG","geometryMaybeCollection","wrapShrink","coordIndex","isGeometryCollection","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","$364b0753f5a881456384b31c1527bf34$export$coordEach","initialValue","previousValue","currentCoord","$364b0753f5a881456384b31c1527bf34$export$propEach","currentProperties","$364b0753f5a881456384b31c1527bf34$export$featureEach","currentFeature","featureProperties","featureBBox","featureId","$364b0753f5a881456384b31c1527bf34$export$geomEach","currentGeometry","coordinate","$364b0753f5a881456384b31c1527bf34$export$flattenEach","feature$$1","segmentIndex","previousCoords","previousFeatureIndex","previousMultiIndex","prevGeomIndex","featureIndexCoord","multiPartIndexCoord","currentSegment","started","$364b0753f5a881456384b31c1527bf34$export$segmentEach","$364b0753f5a881456384b31c1527bf34$export$lineEach","currentLine","p1","p2","sqTolerance","prevPoint","len","$e13ada66fa7c4e11a60260c32accc77e$var$getSqDist","first","last","simplified","maxSqDist","sqDist","$e13ada66fa7c4e11a60260c32accc77e$var$getSqSegDist","$e13ada66fa7c4e11a60260c32accc77e$var$simplifyDPStep","tolerance","highestQuality","$e13ada66fa7c4e11a60260c32accc77e$var$simplifyRadialDist","$e13ada66fa7c4e11a60260c32accc77e$var$simplifyDouglasPeucker","highQuality","$e13ada66fa7c4e11a60260c32accc77e$var$simplifyGeom","$e13ada66fa7c4e11a60260c32accc77e$var$simplifyLine","lines","$e13ada66fa7c4e11a60260c32accc77e$var$simplifyPolygon","rings","$e13ada66fa7c4e11a60260c32accc77e$var$simplify","pts","simpleRing","$e13ada66fa7c4e11a60260c32accc77e$var$checkValidity","schema","indexData","bind","schemaHelper","modifyGeometry","xScale","toClipSpaceFromParts","yScale","data","track","tracks","hasOwnData","currentPoint","getNextDataPoint","filter","getClosestPoint","candidatePoints","closestPoint","distanceToClosestPoint","candidate","dist","selectBox","smallerX","smallerY","largerX","largerY","selectLasso","smallestX","Number","POSITIVE_INFINITY","largestX","NEGATIVE_INFINITY","smallestY","largestY","polygonPoints","boundingPolygon","simplifiedBoundingPolygon","self","onmessage","message","processor","postMessage","selection","bounds","error"],"version":3,"file":"data-processor-worker.39b8c74d.js.map"}