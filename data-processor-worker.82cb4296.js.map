{"mappings":"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","sources":["./node_modules/@parcel/scope-hoisting/lib/helpers.js","./node_modules/kdbush/src/sort.js","./node_modules/kdbush/src/range.js","./node_modules/kdbush/src/within.js","./node_modules/kdbush/src/index.js","./node_modules/supercluster/index.js","./node_modules/@turf/helpers/dist/es/index.js","./node_modules/@turf/invariant/dist/es/index.js","./node_modules/@turf/boolean-point-in-polygon/dist/es/index.js","./node_modules/@turf/clean-coords/dist/es/index.js","./node_modules/@turf/clone/dist/es/index.js","./node_modules/@turf/meta/dist/es/index.js","./node_modules/@turf/simplify/dist/es/index.js","./src/epiviz.gl/data-processor.js","./src/epiviz.gl/data-processor-worker.js"],"sourcesContent":["var $parcel$global =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n    ? self\n    : typeof window !== 'undefined'\n    ? window\n    : typeof global !== 'undefined'\n    ? global\n    : {};\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n}\n\nfunction $parcel$export(e, n, v) {\n  Object.defineProperty(e, n, {get: v, enumerable: true});\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n}\n\nfunction $parcel$missingModule(name) {\n  var err = new Error(\"Cannot find module '\" + name + \"'\");\n  err.code = 'MODULE_NOT_FOUND';\n  throw err;\n}\n","\nexport default function sortKD(ids, coords, nodeSize, left, right, depth) {\n    if (right - left <= nodeSize) return;\n\n    const m = (left + right) >> 1;\n\n    select(ids, coords, m, left, right, depth % 2);\n\n    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);\n    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);\n}\n\nfunction select(ids, coords, k, left, right, inc) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, inc);\n        }\n\n        const t = coords[2 * k + inc];\n        let i = left;\n        let j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + inc] < t) i++;\n            while (coords[2 * j + inc] > t) j--;\n        }\n\n        if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);\n        else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n","\nexport default function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    let x, y;\n\n    while (stack.length) {\n        const axis = stack.pop();\n        const right = stack.pop();\n        const left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (let i = left; i <= right; i++) {\n                x = coords[2 * i];\n                y = coords[2 * i + 1];\n                if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        const m = Math.floor((left + right) / 2);\n\n        x = coords[2 * m];\n        y = coords[2 * m + 1];\n\n        if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\n\n        const nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? minX <= x : minY <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? maxX >= x : maxY >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n","\nexport default function within(ids, coords, qx, qy, r, nodeSize) {\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    const r2 = r * r;\n\n    while (stack.length) {\n        const axis = stack.pop();\n        const right = stack.pop();\n        const left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (let i = left; i <= right; i++) {\n                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        const m = Math.floor((left + right) / 2);\n\n        const x = coords[2 * m];\n        const y = coords[2 * m + 1];\n\n        if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\n\n        const nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? qx - r <= x : qy - r <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? qx + r >= x : qy + r >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n\nfunction sqDist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n","\nimport sort from './sort';\nimport range from './range';\nimport within from './within';\n\nconst defaultGetX = p => p[0];\nconst defaultGetY = p => p[1];\n\nexport default class KDBush {\n    constructor(points, getX = defaultGetX, getY = defaultGetY, nodeSize = 64, ArrayType = Float64Array) {\n        this.nodeSize = nodeSize;\n        this.points = points;\n\n        const IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;\n\n        const ids = this.ids = new IndexArrayType(points.length);\n        const coords = this.coords = new ArrayType(points.length * 2);\n\n        for (let i = 0; i < points.length; i++) {\n            ids[i] = i;\n            coords[2 * i] = getX(points[i]);\n            coords[2 * i + 1] = getY(points[i]);\n        }\n\n        sort(ids, coords, nodeSize, 0, ids.length - 1, 0);\n    }\n\n    range(minX, minY, maxX, maxY) {\n        return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);\n    }\n\n    within(x, y, r) {\n        return within(this.ids, this.coords, x, y, r, this.nodeSize);\n    }\n}\n","\nimport KDBush from 'kdbush';\n\nconst defaultOptions = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    minPoints: 2, // minimum points to form a cluster\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: props => props // props => ({sum: props.my_value})\n};\n\nconst fround = Math.fround || (tmp => ((x) => { tmp[0] = +x; return tmp[0]; }))(new Float32Array(1));\n\nexport default class Supercluster {\n    constructor(options) {\n        this.options = extend(Object.create(defaultOptions), options);\n        this.trees = new Array(this.options.maxZoom + 1);\n    }\n\n    load(points) {\n        const {log, minZoom, maxZoom, nodeSize} = this.options;\n\n        if (log) console.time('total time');\n\n        const timerId = `prepare ${  points.length  } points`;\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        let clusters = [];\n        for (let i = 0; i < points.length; i++) {\n            if (!points[i].geometry) continue;\n            clusters.push(createPointCluster(points[i], i));\n        }\n        this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (let z = maxZoom; z >= minZoom; z--) {\n            const now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            clusters = this._cluster(clusters, z);\n            this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    }\n\n    getClusters(bbox, zoom) {\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        const tree = this.trees[this._limitZoom(zoom)];\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        const clusters = [];\n        for (const id of ids) {\n            const c = tree.points[id];\n            clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n        }\n        return clusters;\n    }\n\n    getChildren(clusterId) {\n        const originId = this._getOriginId(clusterId);\n        const originZoom = this._getOriginZoom(clusterId);\n        const errorMsg = 'No cluster with the specified id.';\n\n        const index = this.trees[originZoom];\n        if (!index) throw new Error(errorMsg);\n\n        const origin = index.points[originId];\n        if (!origin) throw new Error(errorMsg);\n\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        const ids = index.within(origin.x, origin.y, r);\n        const children = [];\n        for (const id of ids) {\n            const c = index.points[id];\n            if (c.parentId === clusterId) {\n                children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    }\n\n    getLeaves(clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        const leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    }\n\n    getTile(z, x, y) {\n        const tree = this.trees[this._limitZoom(z)];\n        const z2 = Math.pow(2, z);\n        const {extent, radius} = this.options;\n        const p = radius / extent;\n        const top = (y - p) / z2;\n        const bottom = (y + 1 + p) / z2;\n\n        const tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.points, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.points, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.points, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    }\n\n    getClusterExpansionZoom(clusterId) {\n        let expansionZoom = this._getOriginZoom(clusterId) - 1;\n        while (expansionZoom <= this.options.maxZoom) {\n            const children = this.getChildren(clusterId);\n            expansionZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return expansionZoom;\n    }\n\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\n        const children = this.getChildren(clusterId);\n\n        for (const child of children) {\n            const props = child.properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(child);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    }\n\n    _addTileFeatures(ids, points, x, y, z2, tile) {\n        for (const i of ids) {\n            const c = points[i];\n            const isCluster = c.numPoints;\n\n            let tags, px, py;\n            if (isCluster) {\n                tags = getClusterProperties(c);\n                px = c.x;\n                py = c.y;\n            } else {\n                const p = this.points[c.index];\n                tags = p.properties;\n                px = lngX(p.geometry.coordinates[0]);\n                py = latY(p.geometry.coordinates[1]);\n            }\n\n            const f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (px * z2 - x)),\n                    Math.round(this.options.extent * (py * z2 - y))\n                ]],\n                tags\n            };\n\n            // assign id\n            let id;\n            if (isCluster) {\n                id = c.id;\n            } else if (this.options.generateId) {\n                // optionally generate id\n                id = c.index;\n            } else if (this.points[c.index].id) {\n                // keep id if already assigned\n                id = this.points[c.index].id;\n            }\n\n            if (id !== undefined) f.id = id;\n\n            tile.features.push(f);\n        }\n    }\n\n    _limitZoom(z) {\n        return Math.max(this.options.minZoom, Math.min(+z, this.options.maxZoom + 1));\n    }\n\n    _cluster(points, zoom) {\n        const clusters = [];\n        const {radius, extent, reduce, minPoints} = this.options;\n        const r = radius / (extent * Math.pow(2, zoom));\n\n        // loop through each point\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            // if we've already visited the point at this zoom level, skip it\n            if (p.zoom <= zoom) continue;\n            p.zoom = zoom;\n\n            // find all nearby points\n            const tree = this.trees[zoom + 1];\n            const neighborIds = tree.within(p.x, p.y, r);\n\n            const numPointsOrigin = p.numPoints || 1;\n            let numPoints = numPointsOrigin;\n\n            // count the number of points in a potential cluster\n            for (const neighborId of neighborIds) {\n                const b = tree.points[neighborId];\n                // filter out neighbors that are already processed\n                if (b.zoom > zoom) numPoints += b.numPoints || 1;\n            }\n\n            if (numPoints >= minPoints) { // enough points to form a cluster\n                let wx = p.x * numPointsOrigin;\n                let wy = p.y * numPointsOrigin;\n\n                let clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null;\n\n                // encode both zoom and point index on which the cluster originated -- offset by total length of features\n                const id = (i << 5) + (zoom + 1) + this.points.length;\n\n                for (const neighborId of neighborIds) {\n                    const b = tree.points[neighborId];\n\n                    if (b.zoom <= zoom) continue;\n                    b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n                    const numPoints2 = b.numPoints || 1;\n                    wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\n                    wy += b.y * numPoints2;\n\n                    b.parentId = id;\n\n                    if (reduce) {\n                        if (!clusterProperties) clusterProperties = this._map(p, true);\n                        reduce(clusterProperties, this._map(b));\n                    }\n                }\n\n                p.parentId = id;\n                clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n\n            } else { // left points as unclustered\n                clusters.push(p);\n\n                if (numPoints > 1) {\n                    for (const neighborId of neighborIds) {\n                        const b = tree.points[neighborId];\n                        if (b.zoom <= zoom) continue;\n                        b.zoom = zoom;\n                        clusters.push(b);\n                    }\n                }\n            }\n        }\n\n        return clusters;\n    }\n\n    // get index of the point from which the cluster originated\n    _getOriginId(clusterId) {\n        return (clusterId - this.points.length) >> 5;\n    }\n\n    // get zoom of the point from which the cluster originated\n    _getOriginZoom(clusterId) {\n        return (clusterId - this.points.length) % 32;\n    }\n\n    _map(point, clone) {\n        if (point.numPoints) {\n            return clone ? extend({}, point.properties) : point.properties;\n        }\n        const original = this.points[point.index].properties;\n        const result = this.options.map(original);\n        return clone && result === original ? extend({}, result) : result;\n    }\n}\n\nfunction createCluster(x, y, id, numPoints, properties) {\n    return {\n        x: fround(x), // weighted cluster center; round for consistency with Float32Array index\n        y: fround(y),\n        zoom: Infinity, // the last zoom the cluster was processed at\n        id, // encodes index of the first child of the cluster and its zoom level\n        parentId: -1, // parent cluster id\n        numPoints,\n        properties\n    };\n}\n\nfunction createPointCluster(p, id) {\n    const [x, y] = p.geometry.coordinates;\n    return {\n        x: fround(lngX(x)), // projected point coordinates\n        y: fround(latY(y)),\n        zoom: Infinity, // the last zoom the point was processed at\n        index: id, // index of the source feature in the original input array,\n        parentId: -1 // parent cluster id\n    };\n}\n\nfunction getClusterJSON(cluster) {\n    return {\n        type: 'Feature',\n        id: cluster.id,\n        properties: getClusterProperties(cluster),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\n        }\n    };\n}\n\nfunction getClusterProperties(cluster) {\n    const count = cluster.numPoints;\n    const abbrev =\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\n    return extend(extend({}, cluster.properties), {\n        cluster: true,\n        cluster_id: cluster.id,\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    const sin = Math.sin(lat * Math.PI / 180);\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    const y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n    for (const id in src) dest[id] = src[id];\n    return dest;\n}\n\nfunction getX(p) {\n    return p.x;\n}\nfunction getY(p) {\n    return p.y;\n}\n","/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n","import { getCoord, getGeom } from \"@turf/invariant\";\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point\n * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Coord} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if\n * the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\nexport default function booleanPointInPolygon(point, polygon, options) {\n    if (options === void 0) { options = {}; }\n    // validation\n    if (!point) {\n        throw new Error(\"point is required\");\n    }\n    if (!polygon) {\n        throw new Error(\"polygon is required\");\n    }\n    var pt = getCoord(point);\n    var geom = getGeom(polygon);\n    var type = geom.type;\n    var bbox = polygon.bbox;\n    var polys = geom.coordinates;\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) {\n        return false;\n    }\n    // normalize to multipolygon\n    if (type === \"Polygon\") {\n        polys = [polys];\n    }\n    var insidePoly = false;\n    for (var i = 0; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) {\n                insidePoly = true;\n            }\n        }\n    }\n    return insidePoly;\n}\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] &&\n        ring[0][1] === ring[ring.length - 1][1]) {\n        ring = ring.slice(0, ring.length - 1);\n    }\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0];\n        var yi = ring[i][1];\n        var xj = ring[j][0];\n        var yj = ring[j][1];\n        var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 &&\n            (xi - pt[0]) * (xj - pt[0]) <= 0 &&\n            (yi - pt[1]) * (yj - pt[1]) <= 0;\n        if (onBoundary) {\n            return !ignoreBoundary;\n        }\n        var intersect = yi > pt[1] !== yj > pt[1] &&\n            pt[0] < ((xj - xi) * (pt[1] - yi)) / (yj - yi) + xi;\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\n/**\n * inBBox\n *\n * @private\n * @param {Position} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return (bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1]);\n}\n","import { feature } from \"@turf/helpers\";\nimport { getCoords, getType } from \"@turf/invariant\";\n// To-Do => Improve Typescript GeoJSON handling\n/**\n * Removes redundant coordinates from any GeoJSON Geometry.\n *\n * @name cleanCoords\n * @param {Geometry|Feature} geojson Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated\n * @returns {Geometry|Feature} the cleaned input Feature/Geometry\n * @example\n * var line = turf.lineString([[0, 0], [0, 2], [0, 5], [0, 8], [0, 8], [0, 10]]);\n * var multiPoint = turf.multiPoint([[0, 0], [0, 0], [2, 2]]);\n *\n * turf.cleanCoords(line).geometry.coordinates;\n * //= [[0, 0], [0, 10]]\n *\n * turf.cleanCoords(multiPoint).geometry.coordinates;\n * //= [[0, 0], [2, 2]]\n */\nfunction cleanCoords(geojson, options) {\n    if (options === void 0) { options = {}; }\n    // Backwards compatible with v4.0\n    var mutate = typeof options === \"object\" ? options.mutate : options;\n    if (!geojson)\n        throw new Error(\"geojson is required\");\n    var type = getType(geojson);\n    // Store new \"clean\" points in this Array\n    var newCoords = [];\n    switch (type) {\n        case \"LineString\":\n            newCoords = cleanLine(geojson);\n            break;\n        case \"MultiLineString\":\n        case \"Polygon\":\n            getCoords(geojson).forEach(function (line) {\n                newCoords.push(cleanLine(line));\n            });\n            break;\n        case \"MultiPolygon\":\n            getCoords(geojson).forEach(function (polygons) {\n                var polyPoints = [];\n                polygons.forEach(function (ring) {\n                    polyPoints.push(cleanLine(ring));\n                });\n                newCoords.push(polyPoints);\n            });\n            break;\n        case \"Point\":\n            return geojson;\n        case \"MultiPoint\":\n            var existing = {};\n            getCoords(geojson).forEach(function (coord) {\n                var key = coord.join(\"-\");\n                if (!existing.hasOwnProperty(key)) {\n                    newCoords.push(coord);\n                    existing[key] = true;\n                }\n            });\n            break;\n        default:\n            throw new Error(type + \" geometry not supported\");\n    }\n    // Support input mutation\n    if (geojson.coordinates) {\n        if (mutate === true) {\n            geojson.coordinates = newCoords;\n            return geojson;\n        }\n        return { type: type, coordinates: newCoords };\n    }\n    else {\n        if (mutate === true) {\n            geojson.geometry.coordinates = newCoords;\n            return geojson;\n        }\n        return feature({ type: type, coordinates: newCoords }, geojson.properties, {\n            bbox: geojson.bbox,\n            id: geojson.id,\n        });\n    }\n}\n/**\n * Clean Coords\n *\n * @private\n * @param {Array<number>|LineString} line Line\n * @returns {Array<number>} Cleaned coordinates\n */\nfunction cleanLine(line) {\n    var points = getCoords(line);\n    // handle \"clean\" segment\n    if (points.length === 2 && !equals(points[0], points[1]))\n        return points;\n    var newPoints = [];\n    var secondToLast = points.length - 1;\n    var newPointsLength = newPoints.length;\n    newPoints.push(points[0]);\n    for (var i = 1; i < secondToLast; i++) {\n        var prevAddedPoint = newPoints[newPoints.length - 1];\n        if (points[i][0] === prevAddedPoint[0] &&\n            points[i][1] === prevAddedPoint[1])\n            continue;\n        else {\n            newPoints.push(points[i]);\n            newPointsLength = newPoints.length;\n            if (newPointsLength > 2) {\n                if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2]))\n                    newPoints.splice(newPoints.length - 2, 1);\n            }\n        }\n    }\n    newPoints.push(points[points.length - 1]);\n    newPointsLength = newPoints.length;\n    if (equals(points[0], points[points.length - 1]) && newPointsLength < 4)\n        throw new Error(\"invalid polygon\");\n    if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2]))\n        newPoints.splice(newPoints.length - 2, 1);\n    return newPoints;\n}\n/**\n * Compares two points and returns if they are equals\n *\n * @private\n * @param {Position} pt1 point\n * @param {Position} pt2 point\n * @returns {boolean} true if they are equals\n */\nfunction equals(pt1, pt2) {\n    return pt1[0] === pt2[0] && pt1[1] === pt2[1];\n}\n/**\n * Returns if `point` is on the segment between `start` and `end`.\n * Borrowed from `@turf/boolean-point-on-line` to speed up the evaluation (instead of using the module as dependency)\n *\n * @private\n * @param {Position} start coord pair of start of line\n * @param {Position} end coord pair of end of line\n * @param {Position} point coord pair of point to check\n * @returns {boolean} true/false\n */\nfunction isPointOnLineSegment(start, end, point) {\n    var x = point[0], y = point[1];\n    var startX = start[0], startY = start[1];\n    var endX = end[0], endY = end[1];\n    var dxc = x - startX;\n    var dyc = y - startY;\n    var dxl = endX - startX;\n    var dyl = endY - startY;\n    var cross = dxc * dyl - dyc * dxl;\n    if (cross !== 0)\n        return false;\n    else if (Math.abs(dxl) >= Math.abs(dyl))\n        return dxl > 0 ? startX <= x && x <= endX : endX <= x && x <= startX;\n    else\n        return dyl > 0 ? startY <= y && y <= endY : endY <= y && y <= startY;\n}\nexport default cleanCoords;\n","/**\n * Returns a cloned copy of the passed GeoJSON Object, including possible 'Foreign Members'.\n * ~3-5x faster than the common JSON.parse + JSON.stringify combo method.\n *\n * @name clone\n * @param {GeoJSON} geojson GeoJSON Object\n * @returns {GeoJSON} cloned GeoJSON Object\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]], {color: 'red'});\n *\n * var lineCloned = turf.clone(line);\n */\nfunction clone(geojson) {\n    if (!geojson) {\n        throw new Error(\"geojson is required\");\n    }\n    switch (geojson.type) {\n        case \"Feature\":\n            return cloneFeature(geojson);\n        case \"FeatureCollection\":\n            return cloneFeatureCollection(geojson);\n        case \"Point\":\n        case \"LineString\":\n        case \"Polygon\":\n        case \"MultiPoint\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\":\n        case \"GeometryCollection\":\n            return cloneGeometry(geojson);\n        default:\n            throw new Error(\"unknown GeoJSON type\");\n    }\n}\n/**\n * Clone Feature\n *\n * @private\n * @param {Feature<any>} geojson GeoJSON Feature\n * @returns {Feature<any>} cloned Feature\n */\nfunction cloneFeature(geojson) {\n    var cloned = { type: \"Feature\" };\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n            case \"type\":\n            case \"properties\":\n            case \"geometry\":\n                return;\n            default:\n                cloned[key] = geojson[key];\n        }\n    });\n    // Add properties & geometry last\n    cloned.properties = cloneProperties(geojson.properties);\n    cloned.geometry = cloneGeometry(geojson.geometry);\n    return cloned;\n}\n/**\n * Clone Properties\n *\n * @private\n * @param {Object} properties GeoJSON Properties\n * @returns {Object} cloned Properties\n */\nfunction cloneProperties(properties) {\n    var cloned = {};\n    if (!properties) {\n        return cloned;\n    }\n    Object.keys(properties).forEach(function (key) {\n        var value = properties[key];\n        if (typeof value === \"object\") {\n            if (value === null) {\n                // handle null\n                cloned[key] = null;\n            }\n            else if (Array.isArray(value)) {\n                // handle Array\n                cloned[key] = value.map(function (item) {\n                    return item;\n                });\n            }\n            else {\n                // handle generic Object\n                cloned[key] = cloneProperties(value);\n            }\n        }\n        else {\n            cloned[key] = value;\n        }\n    });\n    return cloned;\n}\n/**\n * Clone Feature Collection\n *\n * @private\n * @param {FeatureCollection<any>} geojson GeoJSON Feature Collection\n * @returns {FeatureCollection<any>} cloned Feature Collection\n */\nfunction cloneFeatureCollection(geojson) {\n    var cloned = { type: \"FeatureCollection\" };\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n            case \"type\":\n            case \"features\":\n                return;\n            default:\n                cloned[key] = geojson[key];\n        }\n    });\n    // Add features\n    cloned.features = geojson.features.map(function (feature) {\n        return cloneFeature(feature);\n    });\n    return cloned;\n}\n/**\n * Clone Geometry\n *\n * @private\n * @param {Geometry<any>} geometry GeoJSON Geometry\n * @returns {Geometry<any>} cloned Geometry\n */\nfunction cloneGeometry(geometry) {\n    var geom = { type: geometry.type };\n    if (geometry.bbox) {\n        geom.bbox = geometry.bbox;\n    }\n    if (geometry.type === \"GeometryCollection\") {\n        geom.geometries = geometry.geometries.map(function (g) {\n            return cloneGeometry(g);\n        });\n        return geom;\n    }\n    geom.coordinates = deepSlice(geometry.coordinates);\n    return geom;\n}\n/**\n * Deep Slice coordinates\n *\n * @private\n * @param {Coordinates} coords Coordinates\n * @returns {Coordinates} all coordinates sliced\n */\nfunction deepSlice(coords) {\n    var cloned = coords;\n    if (typeof cloned[0] !== \"object\") {\n        return cloned.slice();\n    }\n    return cloned.map(function (coord) {\n        return deepSlice(coord);\n    });\n}\nexport default clone;\n","import { feature, point, lineString, isObject } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature$$1.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature$$1.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature$$1,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = lineString(\n            [previousCoords, currentCoord],\n            feature$$1.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n    if (feature$$1.geometry === null) return;\n    var type = feature$$1.geometry.type;\n    var coords = feature$$1.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              lineString(coords[geometryIndex], feature$$1.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexport { coordEach, coordReduce, propEach, propReduce, featureEach, featureReduce, coordAll, geomEach, geomReduce, flattenEach, flattenReduce, segmentEach, segmentReduce, lineEach, lineReduce, findSegment, findPoint };\n","import cleanCoords from '@turf/clean-coords';\nimport clone from '@turf/clone';\nimport { geomEach } from '@turf/meta';\nimport { isObject } from '@turf/helpers';\n\n/*\n (c) 2013, Vladimir Agafonkin\n Simplify.js, a high-performance JS polyline simplification library\n mourner.github.io/simplify-js\n*/\n\n// to suit your point format, run search/replace for '.x' and '.y';\n// for 3D version, see 3d branch (configurability would draw significant performance overhead)\n\n// square distance between 2 points\nfunction getSqDist(p1, p2) {\n  var dx = p1.x - p2.x,\n    dy = p1.y - p2.y;\n\n  return dx * dx + dy * dy;\n}\n\n// square distance from a point to a segment\nfunction getSqSegDist(p, p1, p2) {\n  var x = p1.x,\n    y = p1.y,\n    dx = p2.x - x,\n    dy = p2.y - y;\n\n  if (dx !== 0 || dy !== 0) {\n    var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);\n\n    if (t > 1) {\n      x = p2.x;\n      y = p2.y;\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n\n  dx = p.x - x;\n  dy = p.y - y;\n\n  return dx * dx + dy * dy;\n}\n// rest of the code doesn't care about point format\n\n// basic distance-based simplification\nfunction simplifyRadialDist(points, sqTolerance) {\n  var prevPoint = points[0],\n    newPoints = [prevPoint],\n    point;\n\n  for (var i = 1, len = points.length; i < len; i++) {\n    point = points[i];\n\n    if (getSqDist(point, prevPoint) > sqTolerance) {\n      newPoints.push(point);\n      prevPoint = point;\n    }\n  }\n\n  if (prevPoint !== point) newPoints.push(point);\n\n  return newPoints;\n}\n\nfunction simplifyDPStep(points, first, last, sqTolerance, simplified) {\n  var maxSqDist = sqTolerance,\n    index;\n\n  for (var i = first + 1; i < last; i++) {\n    var sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n    if (sqDist > maxSqDist) {\n      index = i;\n      maxSqDist = sqDist;\n    }\n  }\n\n  if (maxSqDist > sqTolerance) {\n    if (index - first > 1)\n      simplifyDPStep(points, first, index, sqTolerance, simplified);\n    simplified.push(points[index]);\n    if (last - index > 1)\n      simplifyDPStep(points, index, last, sqTolerance, simplified);\n  }\n}\n\n// simplification using Ramer-Douglas-Peucker algorithm\nfunction simplifyDouglasPeucker(points, sqTolerance) {\n  var last = points.length - 1;\n\n  var simplified = [points[0]];\n  simplifyDPStep(points, 0, last, sqTolerance, simplified);\n  simplified.push(points[last]);\n\n  return simplified;\n}\n\n// both algorithms combined for awesome performance\nfunction simplify(points, tolerance, highestQuality) {\n  if (points.length <= 2) return points;\n\n  var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n\n  points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n  points = simplifyDouglasPeucker(points, sqTolerance);\n\n  return points;\n}\n\n/**\n * Takes a {@link GeoJSON} object and returns a simplified version. Internally uses\n * [simplify-js](http://mourner.github.io/simplify-js/) to perform simplification using the Ramer-Douglas-Peucker algorithm.\n *\n * @name simplify\n * @param {GeoJSON} geojson object to be simplified\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.tolerance=1] simplification tolerance\n * @param {boolean} [options.highQuality=false] whether or not to spend more time to create a higher-quality simplification with a different algorithm\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} a simplified GeoJSON\n * @example\n * var geojson = turf.polygon([[\n *   [-70.603637, -33.399918],\n *   [-70.614624, -33.395332],\n *   [-70.639343, -33.392466],\n *   [-70.659942, -33.394759],\n *   [-70.683975, -33.404504],\n *   [-70.697021, -33.419406],\n *   [-70.701141, -33.434306],\n *   [-70.700454, -33.446339],\n *   [-70.694274, -33.458369],\n *   [-70.682601, -33.465816],\n *   [-70.668869, -33.472117],\n *   [-70.646209, -33.473835],\n *   [-70.624923, -33.472117],\n *   [-70.609817, -33.468107],\n *   [-70.595397, -33.458369],\n *   [-70.587158, -33.442901],\n *   [-70.587158, -33.426283],\n *   [-70.590591, -33.414248],\n *   [-70.594711, -33.406224],\n *   [-70.603637, -33.399918]\n * ]]);\n * var options = {tolerance: 0.01, highQuality: false};\n * var simplified = turf.simplify(geojson, options);\n *\n * //addToMap\n * var addToMap = [geojson, simplified]\n */\nfunction simplify$1(geojson, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var tolerance = options.tolerance !== undefined ? options.tolerance : 1;\n  var highQuality = options.highQuality || false;\n  var mutate = options.mutate || false;\n\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (tolerance && tolerance < 0) throw new Error(\"invalid tolerance\");\n\n  // Clone geojson to avoid side effects\n  if (mutate !== true) geojson = clone(geojson);\n\n  geomEach(geojson, function (geom) {\n    simplifyGeom(geom, tolerance, highQuality);\n  });\n  return geojson;\n}\n\n/**\n * Simplifies a feature's coordinates\n *\n * @private\n * @param {Geometry} geometry to be simplified\n * @param {number} [tolerance=1] simplification tolerance\n * @param {boolean} [highQuality=false] whether or not to spend more time to create a higher-quality simplification with a different algorithm\n * @returns {Geometry} output\n */\nfunction simplifyGeom(geometry, tolerance, highQuality) {\n  var type = geometry.type;\n\n  // \"unsimplyfiable\" geometry types\n  if (type === \"Point\" || type === \"MultiPoint\") return geometry;\n\n  // Remove any extra coordinates\n  cleanCoords(geometry, true);\n\n  var coordinates = geometry.coordinates;\n  switch (type) {\n    case \"LineString\":\n      geometry[\"coordinates\"] = simplifyLine(\n        coordinates,\n        tolerance,\n        highQuality\n      );\n      break;\n    case \"MultiLineString\":\n      geometry[\"coordinates\"] = coordinates.map(function (lines) {\n        return simplifyLine(lines, tolerance, highQuality);\n      });\n      break;\n    case \"Polygon\":\n      geometry[\"coordinates\"] = simplifyPolygon(\n        coordinates,\n        tolerance,\n        highQuality\n      );\n      break;\n    case \"MultiPolygon\":\n      geometry[\"coordinates\"] = coordinates.map(function (rings) {\n        return simplifyPolygon(rings, tolerance, highQuality);\n      });\n  }\n  return geometry;\n}\n\n/**\n * Simplifies the coordinates of a LineString with simplify-js\n *\n * @private\n * @param {Array<number>} coordinates to be processed\n * @param {number} tolerance simplification tolerance\n * @param {boolean} highQuality whether or not to spend more time to create a higher-quality\n * @returns {Array<Array<number>>} simplified coords\n */\nfunction simplifyLine(coordinates, tolerance, highQuality) {\n  return simplify(\n    coordinates.map(function (coord) {\n      return { x: coord[0], y: coord[1], z: coord[2] };\n    }),\n    tolerance,\n    highQuality\n  ).map(function (coords) {\n    return coords.z ? [coords.x, coords.y, coords.z] : [coords.x, coords.y];\n  });\n}\n\n/**\n * Simplifies the coordinates of a Polygon with simplify-js\n *\n * @private\n * @param {Array<number>} coordinates to be processed\n * @param {number} tolerance simplification tolerance\n * @param {boolean} highQuality whether or not to spend more time to create a higher-quality\n * @returns {Array<Array<Array<number>>>} simplified coords\n */\nfunction simplifyPolygon(coordinates, tolerance, highQuality) {\n  return coordinates.map(function (ring) {\n    var pts = ring.map(function (coord) {\n      return { x: coord[0], y: coord[1] };\n    });\n    if (pts.length < 4) {\n      throw new Error(\"invalid polygon\");\n    }\n    var simpleRing = simplify(pts, tolerance, highQuality).map(function (\n      coords\n    ) {\n      return [coords.x, coords.y];\n    });\n    //remove 1 percent of tolerance until enough points to make a triangle\n    while (!checkValidity(simpleRing)) {\n      tolerance -= tolerance * 0.01;\n      simpleRing = simplify(pts, tolerance, highQuality).map(function (\n        coords\n      ) {\n        return [coords.x, coords.y];\n      });\n    }\n    if (\n      simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0] ||\n      simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1]\n    ) {\n      simpleRing.push(simpleRing[0]);\n    }\n    return simpleRing;\n  });\n}\n\n/**\n * Returns true if ring has at least 3 coordinates and its first coordinate is the same as its last\n *\n * @private\n * @param {Array<number>} ring coordinates to be checked\n * @returns {boolean} true if valid\n */\nfunction checkValidity(ring) {\n  if (ring.length < 3) return false;\n  //if the last point is the same as the first, it's not a triangle\n  return !(\n    ring.length === 3 &&\n    ring[2][0] === ring[0][0] &&\n    ring[2][1] === ring[0][1]\n  );\n}\n\nexport default simplify$1;\n","import SchemaProcessor from \"./schema-processor\";\n\nimport Supercluster from \"supercluster\";\nimport booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport { polygon } from \"@turf/helpers\";\nimport simplify from \"@turf/simplify\";\nimport { GenomeScale } from \"./genome-sizes\";\n\nclass DataProcessor {\n  /**\n   * A class meant to handle processing of data used in the scatterplot.\n   *\n   * ** Can currently only handle data in a [-180,180] x [-90, 90] range due\n   * to use of {@link Supercluster}. May need to switch to KDBush at some point.\n   *\n   * @param {Array} data the processor is meant to handle and index\n   */\n  constructor(schema) {\n    this.schema = this.index = new Supercluster();\n\n    console.log(\"Loading data...\");\n\n    new SchemaProcessor(schema, this.indexData.bind(this));\n  }\n\n  /**\n   * Callback function that occurs after the schema processor has loaded the appropriate data\n   *\n   * @param {SchemaProcessor} schemaHelper that is built in the constructor\n   */\n  indexData(schemaHelper) {\n    this.points = [];\n    let modifyGeometry;\n\n    // If we are using genome scales, we need to map the coordinates correctly\n    // We build mapping functions based on what needs to occur for each data\n    // point in order to avoid lots of checks in the potentially very long\n    // data loop.\n    if (schemaHelper.xScale instanceof GenomeScale) {\n      modifyGeometry = (point) => {\n        point.geometry.coordinates[0] =\n          schemaHelper.xScale.toClipSpaceFromParts(\n            point.geometry.coordinates[0][0],\n            point.geometry.coordinates[0][1]\n          );\n      };\n    }\n\n    if (schemaHelper.yScale instanceof GenomeScale) {\n      // This is a way to check if x is also a genome scale, so we don't\n      // include instanceof checks in the data loop\n      if (modifyGeometry) {\n        // x dimension is also a genome scale\n        (point) => {\n          point.geometry.coordinates = [\n            schemaHelper.xScale.toClipSpaceFromParts(\n              point.geometry.coordinates[0][0],\n              point.geometry.coordinates[0][1]\n            ),\n            schemaHelper.yScale.toClipSpaceFromParts(\n              point.geometry.coordinates[0][0],\n              point.geometry.coordinates[0][1]\n            ),\n          ];\n        };\n      } else {\n        modifyGeometry = (point) => {\n          point.geometry.coordinates[1] =\n            schemaHelper.yScale.toClipSpaceFromParts(\n              point.geometry.coordinates[0][0],\n              point.geometry.coordinates[0][1]\n            );\n        };\n      }\n    }\n\n    console.log(\"Reading data...\");\n\n    // Process the global data in the schema processor\n    if (schemaHelper.data) {\n      for (let track of schemaHelper.tracks) {\n        if (!track.hasOwnData) {\n          let currentPoint = track.getNextDataPoint();\n          while (currentPoint) {\n            if (modifyGeometry) {\n              // only call if we need to\n              modifyGeometry(currentPoint);\n            }\n            this.points.push(currentPoint);\n            currentPoint = track.getNextDataPoint();\n          }\n          break;\n        }\n      }\n    }\n\n    // Process the data that is local to each track\n    schemaHelper.tracks\n      .filter((track) => track.hasOwnData)\n      .forEach((track) => {\n        let currentPoint = track.getNextDataPoint();\n        while (currentPoint) {\n          if (modifyGeometry) {\n            modifyGeometry(currentPoint);\n          }\n          this.points.push(currentPoint);\n          currentPoint = track.getNextDataPoint();\n        }\n      });\n\n    console.log(\"Indexing data...\");\n    this.index.load(this.points);\n\n    console.log(\"Data processing complete.\");\n  }\n\n  /**\n   * Find the closest point in the data to a given point. Only finds point if it is\n   * sufficiently close.\n   *\n   * @param {Array} point of two floats to find closest point to\n   * @param {Integer} zoom to pass to supercluster\n   * @returns closest point or undefined\n   */\n  getClosestPoint(point, zoom = 16) {\n    const candidatePoints = this.index.getClusters(\n      [point[0] - 0.01, point[1] - 0.01, point[0] + 0.01, point[1] + 0.01],\n      zoom\n    );\n\n    let closestPoint;\n    let distanceToClosestPoint;\n    for (const candidate of candidatePoints) {\n      const dist =\n        (candidate.geometry.coordinates[0] - point[0]) ** 2 +\n        (candidate.geometry.coordinates[1] - point[1]) ** 2;\n      if (!closestPoint || dist < distanceToClosestPoint) {\n        closestPoint = candidate;\n        distanceToClosestPoint = dist;\n      }\n    }\n\n    return closestPoint;\n  }\n\n  /**\n   * Get points within a bounding box.\n   *\n   * @param {Array} points Bounding rectangle in the format of [x1, y1, x2, y2]\n   * @param {Integer} zoom to pass to supercluster\n   * @returns points in bounding box\n   */\n  selectBox(points, zoom = 16) {\n    const smallerX = Math.min(points[0], points[2]);\n    const smallerY = Math.min(points[1], points[3]);\n    const largerX = Math.max(points[0], points[2]);\n    const largerY = Math.max(points[1], points[3]);\n\n    return this.index.getClusters([smallerX, smallerY, largerX, largerY], zoom);\n  }\n\n  /**\n   * Select points inside a given polygon. Simplify polygon with {@link @turf/simplify}\n   * which may cause precision issues with very complex polygons. Uses {@link turf}\n   * to determine what points are in polygon.\n   *\n   * @param {Array} points of a polygon to select points format: [x1,y1,x2,y2,x3,y3,...]\n   * @param {Integer} zoom to pass to supercluster\n   * @returns points inside lasso\n   */\n  selectLasso(points, zoom = 16) {\n    let smallestX = Number.POSITIVE_INFINITY;\n    let largestX = Number.NEGATIVE_INFINITY;\n    let smallestY = Number.POSITIVE_INFINITY;\n    let largestY = Number.NEGATIVE_INFINITY;\n    const polygonPoints = [];\n    for (let i = 0; i < points.length; i += 2) {\n      if (points[i] < smallestX) smallestX = points[i];\n      if (points[i] > largestX) largestX = points[i];\n      if (points[i + 1] < smallestY) smallestY = points[i + 1];\n      if (points[i + 1] > largestY) largestY = points[i + 1];\n      polygonPoints.push([points[i], points[i + 1]]);\n    }\n\n    polygonPoints.push([...polygonPoints[0]]); // First and last must be same position\n\n    const candidatePoints = this.index.getClusters(\n      [smallestX, smallestY, largestX, largestY],\n      zoom\n    );\n\n    const boundingPolygon = polygon([polygonPoints]);\n\n    const simplifiedBoundingPolygon = simplify(boundingPolygon, {\n      tolerance: 0.01,\n      highQuality: false,\n    });\n\n    return candidatePoints.filter((point) => {\n      return booleanPointInPolygon(\n        point.geometry.coordinates,\n        simplifiedBoundingPolygon\n      );\n    });\n  }\n}\n\nexport default DataProcessor;\n","/**\n * The data processor worker is meant to be an interface between the main thread\n * containing the {@link WebGLVis} a {@link DataProcessor}. It's main purpose\n * is to receive messages from the WebGLVis, call the appropriate method of\n * the DataProcessor, then post a message of the results of the method back to\n * the WebGLVis.\n */\n\nimport DataProcessor from \"./data-processor\";\n\nself.onmessage = (message) => {\n  switch (message.data.type) {\n    case \"init\":\n      self.processor = new DataProcessor(message.data.schema);\n      break;\n    case \"selectBox\":\n      postMessage({\n        type: message.data.type,\n        selection: self.processor.selectBox(message.data.points),\n        bounds: message.data.points,\n      });\n      break;\n    case \"selectLasso\":\n      postMessage({\n        type: message.data.type,\n        selection: self.processor.selectLasso(message.data.points),\n        bounds: message.data.points,\n      });\n      break;\n    case \"getClosestPoint\":\n      postMessage({\n        type: message.data.type,\n        point: self.processor.getClosestPoint(message.data.point),\n      });\n      break;\n    default:\n      console.error(`Received unknown message type: ${message.type}`);\n  }\n};\n"],"names":["$parcel$global","globalThis","self","window","global","ids","coords","nodeSize","left","right","depth","m","$2604e7ef843a7459f41771577fc9183c$var$select","$2604e7ef843a7459f41771577fc9183c$export$default","k","inc","n","z","Math","log","s","exp","sd","sqrt","newLeft","max","floor","newRight","min","t","i","j","$2604e7ef843a7459f41771577fc9183c$var$swapItem","$2604e7ef843a7459f41771577fc9183c$var$swap","arr","tmp","minX","minY","maxX","maxY","stack","length","result","x","y","axis","pop","push","nextAxis","qx","qy","r","r2","$096d289fcf1fd1a3473712905d88d713$var$sqDist","ax","ay","bx","by","dx","dy","$cec8aa2beba66738a8aba4c1486b720b$var$defaultGetX","p","$cec8aa2beba66738a8aba4c1486b720b$var$defaultGetY","constructor","points","getX","getY","ArrayType","Float64Array","IndexArrayType","Uint16Array","Uint32Array","range","within","$df8fb0a35aa61306982e223b3fdb50ad$var$defaultOptions","minZoom","maxZoom","minPoints","radius","extent","generateId","reduce","map","props","$df8fb0a35aa61306982e223b3fdb50ad$var$fround","fround","Float32Array","options","$df8fb0a35aa61306982e223b3fdb50ad$var$extend","Object","create","trees","Array","load","console","time","timerId","clusters","geometry","$df8fb0a35aa61306982e223b3fdb50ad$var$createPointCluster","$df8fb0a35aa61306982e223b3fdb50ad$var$getX","$df8fb0a35aa61306982e223b3fdb50ad$var$getY","timeEnd","now","Date","_cluster","getClusters","bbox","zoom","minLng","minLat","maxLng","maxLat","easternHem","westernHem","concat","tree","_limitZoom","$df8fb0a35aa61306982e223b3fdb50ad$var$lngX","$df8fb0a35aa61306982e223b3fdb50ad$var$latY","id","c","numPoints","$df8fb0a35aa61306982e223b3fdb50ad$var$getClusterJSON","index","getChildren","clusterId","originId","_getOriginId","originZoom","_getOriginZoom","errorMsg","Error","origin","pow","children","parentId","getLeaves","limit","offset","leaves","_appendLeaves","getTile","z2","top","bottom","tile","features","_addTileFeatures","getClusterExpansionZoom","expansionZoom","properties","cluster_id","skipped","child","cluster","point_count","isCluster","tags","px","py","$df8fb0a35aa61306982e223b3fdb50ad$var$getClusterProperties","coordinates","f","type","round","undefined","neighborIds","numPointsOrigin","neighborId","b","wx","wy","clusterProperties","_map","numPoints2","$df8fb0a35aa61306982e223b3fdb50ad$var$createCluster","point","clone","original","Infinity","$df8fb0a35aa61306982e223b3fdb50ad$var$xLng","$df8fb0a35aa61306982e223b3fdb50ad$var$yLat","count","abbrev","point_count_abbreviated","lng","lat","sin","PI","y2","atan","dest","src","$f8afcd2ffd7e50afc2a4e6a9d6a8cb31$export$earthRadius","$f8afcd2ffd7e50afc2a4e6a9d6a8cb31$export$factors","centimeters","centimetres","degrees","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","radians","yards","$f8afcd2ffd7e50afc2a4e6a9d6a8cb31$export$areaFactors","acres","hectares","geom","feat","isArray","$f8afcd2ffd7e50afc2a4e6a9d6a8cb31$export$isNumber","$f8afcd2ffd7e50afc2a4e6a9d6a8cb31$export$feature","_i","coordinates_1","ring","fc","units","factor","distance","num","isNaN","input","coord","$0f23bf02f02182a25d9fb3497411f2a2$export$containsNumber","geojson","_name","polygon","pt","polys","$bd7e548c741d8ed512ad135051375ae7$var$inBBox","insidePoly","$bd7e548c741d8ed512ad135051375ae7$var$inRing","ignoreBoundary","inHole","isInside","slice","xi","yi","xj","yj","onBoundary","intersect","mutate","newCoords","$3e976843cd4c9e77226d53aeaa1c1494$var$cleanLine","forEach","line","polygons","polyPoints","existing","key","join","hasOwnProperty","$3e976843cd4c9e77226d53aeaa1c1494$var$equals","newPoints","secondToLast","newPointsLength","prevAddedPoint","$3e976843cd4c9e77226d53aeaa1c1494$var$isPointOnLineSegment","splice","pt1","pt2","start","end","startX","startY","endX","endY","dxc","dyc","dxl","dyl","cross","abs","$8c01138d69d86724c8da3c490800a12e$var$cloneFeature","$8c01138d69d86724c8da3c490800a12e$var$cloneFeatureCollection","$8c01138d69d86724c8da3c490800a12e$var$cloneGeometry","cloned","keys","$8c01138d69d86724c8da3c490800a12e$var$cloneProperties","value","item","feature","geometries","g","$8c01138d69d86724c8da3c490800a12e$var$deepSlice","callback","excludeWrapCoord","l","stopG","geometryMaybeCollection","wrapShrink","coordIndex","isGeometryCollection","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","$cbbd2e42bceedf1f57ecf044e40594fe$export$coordEach","initialValue","previousValue","currentCoord","$cbbd2e42bceedf1f57ecf044e40594fe$export$propEach","currentProperties","$cbbd2e42bceedf1f57ecf044e40594fe$export$featureEach","currentFeature","featureProperties","featureBBox","featureId","$cbbd2e42bceedf1f57ecf044e40594fe$export$geomEach","currentGeometry","coordinate","$cbbd2e42bceedf1f57ecf044e40594fe$export$flattenEach","feature$$1","segmentIndex","previousCoords","previousFeatureIndex","previousMultiIndex","prevGeomIndex","featureIndexCoord","multiPartIndexCoord","currentSegment","started","$cbbd2e42bceedf1f57ecf044e40594fe$export$segmentEach","$cbbd2e42bceedf1f57ecf044e40594fe$export$lineEach","currentLine","p1","p2","sqTolerance","prevPoint","len","$9143ed0117c5e2d9ab3ca2a3f322fc7d$var$getSqDist","first","last","simplified","maxSqDist","sqDist","$9143ed0117c5e2d9ab3ca2a3f322fc7d$var$getSqSegDist","$9143ed0117c5e2d9ab3ca2a3f322fc7d$var$simplifyDPStep","tolerance","highestQuality","$9143ed0117c5e2d9ab3ca2a3f322fc7d$var$simplifyRadialDist","$9143ed0117c5e2d9ab3ca2a3f322fc7d$var$simplifyDouglasPeucker","highQuality","$9143ed0117c5e2d9ab3ca2a3f322fc7d$var$simplifyGeom","$9143ed0117c5e2d9ab3ca2a3f322fc7d$var$simplifyLine","lines","$9143ed0117c5e2d9ab3ca2a3f322fc7d$var$simplifyPolygon","rings","$9143ed0117c5e2d9ab3ca2a3f322fc7d$var$simplify","pts","simpleRing","$9143ed0117c5e2d9ab3ca2a3f322fc7d$var$checkValidity","schema","indexData","bind","schemaHelper","modifyGeometry","xScale","toClipSpaceFromParts","yScale","data","track","tracks","hasOwnData","currentPoint","getNextDataPoint","filter","getClosestPoint","candidatePoints","closestPoint","distanceToClosestPoint","candidate","dist","selectBox","smallerX","smallerY","largerX","largerY","selectLasso","smallestX","Number","POSITIVE_INFINITY","largestX","NEGATIVE_INFINITY","smallestY","largestY","polygonPoints","boundingPolygon","simplifiedBoundingPolygon","onmessage","message","processor","postMessage","selection","bounds","error"],"version":3,"file":"data-processor-worker.82cb4296.js.map"}