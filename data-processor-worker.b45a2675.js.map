{"version":3,"sources":["../../node_modules/kdbush/src/sort.js","../../node_modules/kdbush/src/range.js","../../node_modules/kdbush/src/within.js","../../node_modules/kdbush/src/index.js","../../node_modules/supercluster/index.js","../scripts/data-processor.js","../scripts/data-processor-worker.js"],"names":["sortKD","ids","coords","nodeSize","left","right","depth","m","select","k","inc","n","z","Math","log","s","exp","sd","sqrt","max","floor","min","t","i","j","swapItem","swap","arr","tmp","range","minX","minY","maxX","maxY","stack","length","result","x","y","axis","pop","push","nextAxis","within","qx","qy","r","r2","sqDist","ax","ay","bx","by","dx","dy","defaultGetX","p","defaultGetY","KDBush","constructor","points","getX","getY","ArrayType","Float64Array","IndexArrayType","Uint16Array","Uint32Array","defaultOptions","minZoom","maxZoom","minPoints","radius","extent","generateId","reduce","map","props","fround","Float32Array","Supercluster","options","extend","Object","create","trees","Array","load","console","time","timerId","clusters","geometry","createPointCluster","timeEnd","now","Date","_cluster","getClusters","bbox","zoom","minLng","minLat","maxLng","maxLat","easternHem","westernHem","concat","tree","_limitZoom","lngX","latY","id","c","numPoints","getClusterJSON","index","getChildren","clusterId","originId","_getOriginId","originZoom","_getOriginZoom","errorMsg","Error","origin","pow","children","parentId","getLeaves","limit","offset","leaves","_appendLeaves","getTile","z2","top","bottom","tile","features","_addTileFeatures","getClusterExpansionZoom","expansionZoom","properties","cluster_id","skipped","child","cluster","point_count","isCluster","tags","px","py","getClusterProperties","coordinates","f","type","round","undefined","neighborIds","numPointsOrigin","neighborId","b","wx","wy","clusterProperties","_map","numPoints2","createCluster","point","clone","original","Infinity","xLng","yLat","count","abbrev","point_count_abbreviated","lng","lat","sin","PI","y2","atan","dest","src","DataProcessor","data","split","forEach","line","parts","parseFloat","isNaN","sample","smallerX","smallerY","largerX","largerY","self","onmessage","message","processor","selectBox","selectLasso","error","e"],"mappings":"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","file":"data-processor-worker.b45a2675.js","sourceRoot":"../src/pages","sourcesContent":["\nexport default function sortKD(ids, coords, nodeSize, left, right, depth) {\n    if (right - left <= nodeSize) return;\n\n    const m = (left + right) >> 1;\n\n    select(ids, coords, m, left, right, depth % 2);\n\n    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);\n    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);\n}\n\nfunction select(ids, coords, k, left, right, inc) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, inc);\n        }\n\n        const t = coords[2 * k + inc];\n        let i = left;\n        let j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + inc] < t) i++;\n            while (coords[2 * j + inc] > t) j--;\n        }\n\n        if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);\n        else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n","\nexport default function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    let x, y;\n\n    while (stack.length) {\n        const axis = stack.pop();\n        const right = stack.pop();\n        const left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (let i = left; i <= right; i++) {\n                x = coords[2 * i];\n                y = coords[2 * i + 1];\n                if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        const m = Math.floor((left + right) / 2);\n\n        x = coords[2 * m];\n        y = coords[2 * m + 1];\n\n        if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\n\n        const nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? minX <= x : minY <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? maxX >= x : maxY >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n","\nexport default function within(ids, coords, qx, qy, r, nodeSize) {\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    const r2 = r * r;\n\n    while (stack.length) {\n        const axis = stack.pop();\n        const right = stack.pop();\n        const left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (let i = left; i <= right; i++) {\n                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        const m = Math.floor((left + right) / 2);\n\n        const x = coords[2 * m];\n        const y = coords[2 * m + 1];\n\n        if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\n\n        const nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? qx - r <= x : qy - r <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? qx + r >= x : qy + r >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n\nfunction sqDist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n","\nimport sort from './sort';\nimport range from './range';\nimport within from './within';\n\nconst defaultGetX = p => p[0];\nconst defaultGetY = p => p[1];\n\nexport default class KDBush {\n    constructor(points, getX = defaultGetX, getY = defaultGetY, nodeSize = 64, ArrayType = Float64Array) {\n        this.nodeSize = nodeSize;\n        this.points = points;\n\n        const IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;\n\n        const ids = this.ids = new IndexArrayType(points.length);\n        const coords = this.coords = new ArrayType(points.length * 2);\n\n        for (let i = 0; i < points.length; i++) {\n            ids[i] = i;\n            coords[2 * i] = getX(points[i]);\n            coords[2 * i + 1] = getY(points[i]);\n        }\n\n        sort(ids, coords, nodeSize, 0, ids.length - 1, 0);\n    }\n\n    range(minX, minY, maxX, maxY) {\n        return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);\n    }\n\n    within(x, y, r) {\n        return within(this.ids, this.coords, x, y, r, this.nodeSize);\n    }\n}\n","\nimport KDBush from 'kdbush';\n\nconst defaultOptions = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    minPoints: 2, // minimum points to form a cluster\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: props => props // props => ({sum: props.my_value})\n};\n\nconst fround = Math.fround || (tmp => ((x) => { tmp[0] = +x; return tmp[0]; }))(new Float32Array(1));\n\nexport default class Supercluster {\n    constructor(options) {\n        this.options = extend(Object.create(defaultOptions), options);\n        this.trees = new Array(this.options.maxZoom + 1);\n    }\n\n    load(points) {\n        const {log, minZoom, maxZoom, nodeSize} = this.options;\n\n        if (log) console.time('total time');\n\n        const timerId = `prepare ${  points.length  } points`;\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        let clusters = [];\n        for (let i = 0; i < points.length; i++) {\n            if (!points[i].geometry) continue;\n            clusters.push(createPointCluster(points[i], i));\n        }\n        this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (let z = maxZoom; z >= minZoom; z--) {\n            const now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            clusters = this._cluster(clusters, z);\n            this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    }\n\n    getClusters(bbox, zoom) {\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        const tree = this.trees[this._limitZoom(zoom)];\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        const clusters = [];\n        for (const id of ids) {\n            const c = tree.points[id];\n            clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n        }\n        return clusters;\n    }\n\n    getChildren(clusterId) {\n        const originId = this._getOriginId(clusterId);\n        const originZoom = this._getOriginZoom(clusterId);\n        const errorMsg = 'No cluster with the specified id.';\n\n        const index = this.trees[originZoom];\n        if (!index) throw new Error(errorMsg);\n\n        const origin = index.points[originId];\n        if (!origin) throw new Error(errorMsg);\n\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        const ids = index.within(origin.x, origin.y, r);\n        const children = [];\n        for (const id of ids) {\n            const c = index.points[id];\n            if (c.parentId === clusterId) {\n                children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    }\n\n    getLeaves(clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        const leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    }\n\n    getTile(z, x, y) {\n        const tree = this.trees[this._limitZoom(z)];\n        const z2 = Math.pow(2, z);\n        const {extent, radius} = this.options;\n        const p = radius / extent;\n        const top = (y - p) / z2;\n        const bottom = (y + 1 + p) / z2;\n\n        const tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.points, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.points, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.points, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    }\n\n    getClusterExpansionZoom(clusterId) {\n        let expansionZoom = this._getOriginZoom(clusterId) - 1;\n        while (expansionZoom <= this.options.maxZoom) {\n            const children = this.getChildren(clusterId);\n            expansionZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return expansionZoom;\n    }\n\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\n        const children = this.getChildren(clusterId);\n\n        for (const child of children) {\n            const props = child.properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(child);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    }\n\n    _addTileFeatures(ids, points, x, y, z2, tile) {\n        for (const i of ids) {\n            const c = points[i];\n            const isCluster = c.numPoints;\n\n            let tags, px, py;\n            if (isCluster) {\n                tags = getClusterProperties(c);\n                px = c.x;\n                py = c.y;\n            } else {\n                const p = this.points[c.index];\n                tags = p.properties;\n                px = lngX(p.geometry.coordinates[0]);\n                py = latY(p.geometry.coordinates[1]);\n            }\n\n            const f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (px * z2 - x)),\n                    Math.round(this.options.extent * (py * z2 - y))\n                ]],\n                tags\n            };\n\n            // assign id\n            let id;\n            if (isCluster) {\n                id = c.id;\n            } else if (this.options.generateId) {\n                // optionally generate id\n                id = c.index;\n            } else if (this.points[c.index].id) {\n                // keep id if already assigned\n                id = this.points[c.index].id;\n            }\n\n            if (id !== undefined) f.id = id;\n\n            tile.features.push(f);\n        }\n    }\n\n    _limitZoom(z) {\n        return Math.max(this.options.minZoom, Math.min(+z, this.options.maxZoom + 1));\n    }\n\n    _cluster(points, zoom) {\n        const clusters = [];\n        const {radius, extent, reduce, minPoints} = this.options;\n        const r = radius / (extent * Math.pow(2, zoom));\n\n        // loop through each point\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            // if we've already visited the point at this zoom level, skip it\n            if (p.zoom <= zoom) continue;\n            p.zoom = zoom;\n\n            // find all nearby points\n            const tree = this.trees[zoom + 1];\n            const neighborIds = tree.within(p.x, p.y, r);\n\n            const numPointsOrigin = p.numPoints || 1;\n            let numPoints = numPointsOrigin;\n\n            // count the number of points in a potential cluster\n            for (const neighborId of neighborIds) {\n                const b = tree.points[neighborId];\n                // filter out neighbors that are already processed\n                if (b.zoom > zoom) numPoints += b.numPoints || 1;\n            }\n\n            if (numPoints >= minPoints) { // enough points to form a cluster\n                let wx = p.x * numPointsOrigin;\n                let wy = p.y * numPointsOrigin;\n\n                let clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null;\n\n                // encode both zoom and point index on which the cluster originated -- offset by total length of features\n                const id = (i << 5) + (zoom + 1) + this.points.length;\n\n                for (const neighborId of neighborIds) {\n                    const b = tree.points[neighborId];\n\n                    if (b.zoom <= zoom) continue;\n                    b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n                    const numPoints2 = b.numPoints || 1;\n                    wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\n                    wy += b.y * numPoints2;\n\n                    b.parentId = id;\n\n                    if (reduce) {\n                        if (!clusterProperties) clusterProperties = this._map(p, true);\n                        reduce(clusterProperties, this._map(b));\n                    }\n                }\n\n                p.parentId = id;\n                clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n\n            } else { // left points as unclustered\n                clusters.push(p);\n\n                if (numPoints > 1) {\n                    for (const neighborId of neighborIds) {\n                        const b = tree.points[neighborId];\n                        if (b.zoom <= zoom) continue;\n                        b.zoom = zoom;\n                        clusters.push(b);\n                    }\n                }\n            }\n        }\n\n        return clusters;\n    }\n\n    // get index of the point from which the cluster originated\n    _getOriginId(clusterId) {\n        return (clusterId - this.points.length) >> 5;\n    }\n\n    // get zoom of the point from which the cluster originated\n    _getOriginZoom(clusterId) {\n        return (clusterId - this.points.length) % 32;\n    }\n\n    _map(point, clone) {\n        if (point.numPoints) {\n            return clone ? extend({}, point.properties) : point.properties;\n        }\n        const original = this.points[point.index].properties;\n        const result = this.options.map(original);\n        return clone && result === original ? extend({}, result) : result;\n    }\n}\n\nfunction createCluster(x, y, id, numPoints, properties) {\n    return {\n        x: fround(x), // weighted cluster center; round for consistency with Float32Array index\n        y: fround(y),\n        zoom: Infinity, // the last zoom the cluster was processed at\n        id, // encodes index of the first child of the cluster and its zoom level\n        parentId: -1, // parent cluster id\n        numPoints,\n        properties\n    };\n}\n\nfunction createPointCluster(p, id) {\n    const [x, y] = p.geometry.coordinates;\n    return {\n        x: fround(lngX(x)), // projected point coordinates\n        y: fround(latY(y)),\n        zoom: Infinity, // the last zoom the point was processed at\n        index: id, // index of the source feature in the original input array,\n        parentId: -1 // parent cluster id\n    };\n}\n\nfunction getClusterJSON(cluster) {\n    return {\n        type: 'Feature',\n        id: cluster.id,\n        properties: getClusterProperties(cluster),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\n        }\n    };\n}\n\nfunction getClusterProperties(cluster) {\n    const count = cluster.numPoints;\n    const abbrev =\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\n    return extend(extend({}, cluster.properties), {\n        cluster: true,\n        cluster_id: cluster.id,\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    const sin = Math.sin(lat * Math.PI / 180);\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    const y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n    for (const id in src) dest[id] = src[id];\n    return dest;\n}\n\nfunction getX(p) {\n    return p.x;\n}\nfunction getY(p) {\n    return p.y;\n}\n","import Supercluster from \"supercluster\";\n\nclass DataProcessor {\n  constructor(data) {\n    this.index = new Supercluster();\n    this.points = [];\n    // specific to t-SNE\n\n    console.log(\"Reading data...\");\n    data.split(\"\\n\").forEach((line) => {\n      const parts = line.split(\",\");\n      const x = parseFloat(parts[1]);\n      const y = parseFloat(parts[2]);\n      if (!parts[0] || isNaN(x) || isNaN(y)) {\n        return;\n      }\n      this.points.push({\n        geometry: {\n          coordinates: [x, y],\n          sample: parts[0],\n        },\n      });\n    });\n\n    console.log(\"Indexing data...\");\n    this.index.load(this.points);\n\n    console.log(\"Data ready.\");\n  }\n\n  selectBox(points, zoom = 16) {\n    const smallerX = Math.min(points[0], points[2]);\n    const smallerY = Math.min(points[1], points[3]);\n    const largerX = Math.max(points[0], points[2]);\n    const largerY = Math.max(points[1], points[3]);\n\n    console.log(\n      this.index.getClusters([smallerX, smallerY, largerX, largerY], zoom)\n    );\n  }\n\n  selectLasso(data, zoom = 16) {}\n}\n\nexport default DataProcessor;\n","import DataProcessor from \"./data-processor\";\n\nself.onmessage = (message) => {\n  switch (message.data.type) {\n    case \"init\":\n      self.processor = new DataProcessor(message.data.data);\n      break;\n    case \"selectBox\":\n      self.processor.selectBox(message.data.points);\n      break;\n    case \"selectLasso\":\n      self.processor.selectLasso(message.data);\n    default:\n      console.error(`Received unknown message type: ${e}`);\n  }\n};\n"]}