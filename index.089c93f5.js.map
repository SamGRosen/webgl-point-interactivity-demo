{"mappings":"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","sources":["./node_modules/@parcel/scope-hoisting/lib/helpers.js","./node_modules/@parcel/scope-hoisting/lib/prelude.js","./node_modules/kdbush/src/sort.js","./node_modules/kdbush/src/within.js","./node_modules/kdbush/src/index.js","./node_modules/kdbush/src/range.js","./node_modules/supercluster/index.js","./node_modules/@turf/helpers/dist/es/index.js","./node_modules/@turf/boolean-point-in-polygon/dist/es/index.js","./node_modules/@turf/invariant/dist/es/index.js","./src/scripts/data-processor.js"],"sourcesContent":["var $parcel$global =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n    ? self\n    : typeof window !== 'undefined'\n    ? window\n    : typeof global !== 'undefined'\n    ? global\n    : {};\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n}\n\nfunction $parcel$export(e, n, v) {\n  Object.defineProperty(e, n, {get: v, enumerable: true});\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n}\n\nfunction $parcel$missingModule(name) {\n  var err = new Error(\"Cannot find module '\" + name + \"'\");\n  err.code = 'MODULE_NOT_FOUND';\n  throw err;\n}\n","var $parcel$modules = {};\nvar $parcel$bundles = {};\n\nif (parcelRequire == null) {\n  parcelRequire = function(name) {\n    // Execute the bundle wrapper function if there is one registered.\n    if (name in $parcel$bundles) {\n      let wrapper = $parcel$bundles[name];\n      delete $parcel$bundles[name];\n      wrapper();\n    }\n\n    if (name in $parcel$modules) {\n      return $parcel$modules[name];\n    }\n\n    // Try the node require function if it exists.\n    // Do not use `require` to prevent Webpack from trying to bundle this call\n    if (typeof module !== 'undefined' && typeof module.require === 'function') {\n      return module.require(name);\n    }\n\n    var err = new Error(\"Cannot find module '\" + name + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, exports) {\n    $parcel$modules[id] = exports;\n  };\n\n  parcelRequire.registerBundle = function registerBundle(id, fn) {\n    $parcel$bundles[id] = fn;\n    $parcel$modules[id] = {};\n  };\n\n  $parcel$global[parcelRequireName] = parcelRequire;\n}\n","\nexport default function sortKD(ids, coords, nodeSize, left, right, depth) {\n    if (right - left <= nodeSize) return;\n\n    const m = (left + right) >> 1;\n\n    select(ids, coords, m, left, right, depth % 2);\n\n    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);\n    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);\n}\n\nfunction select(ids, coords, k, left, right, inc) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, inc);\n        }\n\n        const t = coords[2 * k + inc];\n        let i = left;\n        let j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + inc] < t) i++;\n            while (coords[2 * j + inc] > t) j--;\n        }\n\n        if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);\n        else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n","\nexport default function within(ids, coords, qx, qy, r, nodeSize) {\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    const r2 = r * r;\n\n    while (stack.length) {\n        const axis = stack.pop();\n        const right = stack.pop();\n        const left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (let i = left; i <= right; i++) {\n                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        const m = Math.floor((left + right) / 2);\n\n        const x = coords[2 * m];\n        const y = coords[2 * m + 1];\n\n        if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\n\n        const nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? qx - r <= x : qy - r <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? qx + r >= x : qy + r >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n\nfunction sqDist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n","\nimport sort from './sort';\nimport range from './range';\nimport within from './within';\n\nconst defaultGetX = p => p[0];\nconst defaultGetY = p => p[1];\n\nexport default class KDBush {\n    constructor(points, getX = defaultGetX, getY = defaultGetY, nodeSize = 64, ArrayType = Float64Array) {\n        this.nodeSize = nodeSize;\n        this.points = points;\n\n        const IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;\n\n        const ids = this.ids = new IndexArrayType(points.length);\n        const coords = this.coords = new ArrayType(points.length * 2);\n\n        for (let i = 0; i < points.length; i++) {\n            ids[i] = i;\n            coords[2 * i] = getX(points[i]);\n            coords[2 * i + 1] = getY(points[i]);\n        }\n\n        sort(ids, coords, nodeSize, 0, ids.length - 1, 0);\n    }\n\n    range(minX, minY, maxX, maxY) {\n        return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);\n    }\n\n    within(x, y, r) {\n        return within(this.ids, this.coords, x, y, r, this.nodeSize);\n    }\n}\n","\nexport default function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    let x, y;\n\n    while (stack.length) {\n        const axis = stack.pop();\n        const right = stack.pop();\n        const left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (let i = left; i <= right; i++) {\n                x = coords[2 * i];\n                y = coords[2 * i + 1];\n                if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        const m = Math.floor((left + right) / 2);\n\n        x = coords[2 * m];\n        y = coords[2 * m + 1];\n\n        if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\n\n        const nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? minX <= x : minY <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? maxX >= x : maxY >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n","\nimport KDBush from 'kdbush';\n\nconst defaultOptions = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    minPoints: 2, // minimum points to form a cluster\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: props => props // props => ({sum: props.my_value})\n};\n\nconst fround = Math.fround || (tmp => ((x) => { tmp[0] = +x; return tmp[0]; }))(new Float32Array(1));\n\nexport default class Supercluster {\n    constructor(options) {\n        this.options = extend(Object.create(defaultOptions), options);\n        this.trees = new Array(this.options.maxZoom + 1);\n    }\n\n    load(points) {\n        const {log, minZoom, maxZoom, nodeSize} = this.options;\n\n        if (log) console.time('total time');\n\n        const timerId = `prepare ${  points.length  } points`;\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        let clusters = [];\n        for (let i = 0; i < points.length; i++) {\n            if (!points[i].geometry) continue;\n            clusters.push(createPointCluster(points[i], i));\n        }\n        this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (let z = maxZoom; z >= minZoom; z--) {\n            const now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            clusters = this._cluster(clusters, z);\n            this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    }\n\n    getClusters(bbox, zoom) {\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        const tree = this.trees[this._limitZoom(zoom)];\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        const clusters = [];\n        for (const id of ids) {\n            const c = tree.points[id];\n            clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n        }\n        return clusters;\n    }\n\n    getChildren(clusterId) {\n        const originId = this._getOriginId(clusterId);\n        const originZoom = this._getOriginZoom(clusterId);\n        const errorMsg = 'No cluster with the specified id.';\n\n        const index = this.trees[originZoom];\n        if (!index) throw new Error(errorMsg);\n\n        const origin = index.points[originId];\n        if (!origin) throw new Error(errorMsg);\n\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        const ids = index.within(origin.x, origin.y, r);\n        const children = [];\n        for (const id of ids) {\n            const c = index.points[id];\n            if (c.parentId === clusterId) {\n                children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    }\n\n    getLeaves(clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        const leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    }\n\n    getTile(z, x, y) {\n        const tree = this.trees[this._limitZoom(z)];\n        const z2 = Math.pow(2, z);\n        const {extent, radius} = this.options;\n        const p = radius / extent;\n        const top = (y - p) / z2;\n        const bottom = (y + 1 + p) / z2;\n\n        const tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.points, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.points, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.points, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    }\n\n    getClusterExpansionZoom(clusterId) {\n        let expansionZoom = this._getOriginZoom(clusterId) - 1;\n        while (expansionZoom <= this.options.maxZoom) {\n            const children = this.getChildren(clusterId);\n            expansionZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return expansionZoom;\n    }\n\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\n        const children = this.getChildren(clusterId);\n\n        for (const child of children) {\n            const props = child.properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(child);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    }\n\n    _addTileFeatures(ids, points, x, y, z2, tile) {\n        for (const i of ids) {\n            const c = points[i];\n            const isCluster = c.numPoints;\n\n            let tags, px, py;\n            if (isCluster) {\n                tags = getClusterProperties(c);\n                px = c.x;\n                py = c.y;\n            } else {\n                const p = this.points[c.index];\n                tags = p.properties;\n                px = lngX(p.geometry.coordinates[0]);\n                py = latY(p.geometry.coordinates[1]);\n            }\n\n            const f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (px * z2 - x)),\n                    Math.round(this.options.extent * (py * z2 - y))\n                ]],\n                tags\n            };\n\n            // assign id\n            let id;\n            if (isCluster) {\n                id = c.id;\n            } else if (this.options.generateId) {\n                // optionally generate id\n                id = c.index;\n            } else if (this.points[c.index].id) {\n                // keep id if already assigned\n                id = this.points[c.index].id;\n            }\n\n            if (id !== undefined) f.id = id;\n\n            tile.features.push(f);\n        }\n    }\n\n    _limitZoom(z) {\n        return Math.max(this.options.minZoom, Math.min(+z, this.options.maxZoom + 1));\n    }\n\n    _cluster(points, zoom) {\n        const clusters = [];\n        const {radius, extent, reduce, minPoints} = this.options;\n        const r = radius / (extent * Math.pow(2, zoom));\n\n        // loop through each point\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            // if we've already visited the point at this zoom level, skip it\n            if (p.zoom <= zoom) continue;\n            p.zoom = zoom;\n\n            // find all nearby points\n            const tree = this.trees[zoom + 1];\n            const neighborIds = tree.within(p.x, p.y, r);\n\n            const numPointsOrigin = p.numPoints || 1;\n            let numPoints = numPointsOrigin;\n\n            // count the number of points in a potential cluster\n            for (const neighborId of neighborIds) {\n                const b = tree.points[neighborId];\n                // filter out neighbors that are already processed\n                if (b.zoom > zoom) numPoints += b.numPoints || 1;\n            }\n\n            if (numPoints >= minPoints) { // enough points to form a cluster\n                let wx = p.x * numPointsOrigin;\n                let wy = p.y * numPointsOrigin;\n\n                let clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null;\n\n                // encode both zoom and point index on which the cluster originated -- offset by total length of features\n                const id = (i << 5) + (zoom + 1) + this.points.length;\n\n                for (const neighborId of neighborIds) {\n                    const b = tree.points[neighborId];\n\n                    if (b.zoom <= zoom) continue;\n                    b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n                    const numPoints2 = b.numPoints || 1;\n                    wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\n                    wy += b.y * numPoints2;\n\n                    b.parentId = id;\n\n                    if (reduce) {\n                        if (!clusterProperties) clusterProperties = this._map(p, true);\n                        reduce(clusterProperties, this._map(b));\n                    }\n                }\n\n                p.parentId = id;\n                clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n\n            } else { // left points as unclustered\n                clusters.push(p);\n\n                if (numPoints > 1) {\n                    for (const neighborId of neighborIds) {\n                        const b = tree.points[neighborId];\n                        if (b.zoom <= zoom) continue;\n                        b.zoom = zoom;\n                        clusters.push(b);\n                    }\n                }\n            }\n        }\n\n        return clusters;\n    }\n\n    // get index of the point from which the cluster originated\n    _getOriginId(clusterId) {\n        return (clusterId - this.points.length) >> 5;\n    }\n\n    // get zoom of the point from which the cluster originated\n    _getOriginZoom(clusterId) {\n        return (clusterId - this.points.length) % 32;\n    }\n\n    _map(point, clone) {\n        if (point.numPoints) {\n            return clone ? extend({}, point.properties) : point.properties;\n        }\n        const original = this.points[point.index].properties;\n        const result = this.options.map(original);\n        return clone && result === original ? extend({}, result) : result;\n    }\n}\n\nfunction createCluster(x, y, id, numPoints, properties) {\n    return {\n        x: fround(x), // weighted cluster center; round for consistency with Float32Array index\n        y: fround(y),\n        zoom: Infinity, // the last zoom the cluster was processed at\n        id, // encodes index of the first child of the cluster and its zoom level\n        parentId: -1, // parent cluster id\n        numPoints,\n        properties\n    };\n}\n\nfunction createPointCluster(p, id) {\n    const [x, y] = p.geometry.coordinates;\n    return {\n        x: fround(lngX(x)), // projected point coordinates\n        y: fround(latY(y)),\n        zoom: Infinity, // the last zoom the point was processed at\n        index: id, // index of the source feature in the original input array,\n        parentId: -1 // parent cluster id\n    };\n}\n\nfunction getClusterJSON(cluster) {\n    return {\n        type: 'Feature',\n        id: cluster.id,\n        properties: getClusterProperties(cluster),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\n        }\n    };\n}\n\nfunction getClusterProperties(cluster) {\n    const count = cluster.numPoints;\n    const abbrev =\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\n    return extend(extend({}, cluster.properties), {\n        cluster: true,\n        cluster_id: cluster.id,\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    const sin = Math.sin(lat * Math.PI / 180);\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    const y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n    for (const id in src) dest[id] = src[id];\n    return dest;\n}\n\nfunction getX(p) {\n    return p.x;\n}\nfunction getY(p) {\n    return p.y;\n}\n","/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","import { getCoord, getGeom } from \"@turf/invariant\";\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point\n * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Coord} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if\n * the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\nexport default function booleanPointInPolygon(point, polygon, options) {\n    if (options === void 0) { options = {}; }\n    // validation\n    if (!point) {\n        throw new Error(\"point is required\");\n    }\n    if (!polygon) {\n        throw new Error(\"polygon is required\");\n    }\n    var pt = getCoord(point);\n    var geom = getGeom(polygon);\n    var type = geom.type;\n    var bbox = polygon.bbox;\n    var polys = geom.coordinates;\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) {\n        return false;\n    }\n    // normalize to multipolygon\n    if (type === \"Polygon\") {\n        polys = [polys];\n    }\n    var insidePoly = false;\n    for (var i = 0; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) {\n                insidePoly = true;\n            }\n        }\n    }\n    return insidePoly;\n}\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] &&\n        ring[0][1] === ring[ring.length - 1][1]) {\n        ring = ring.slice(0, ring.length - 1);\n    }\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0];\n        var yi = ring[i][1];\n        var xj = ring[j][0];\n        var yj = ring[j][1];\n        var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 &&\n            (xi - pt[0]) * (xj - pt[0]) <= 0 &&\n            (yi - pt[1]) * (yj - pt[1]) <= 0;\n        if (onBoundary) {\n            return !ignoreBoundary;\n        }\n        var intersect = yi > pt[1] !== yj > pt[1] &&\n            pt[0] < ((xj - xi) * (pt[1] - yi)) / (yj - yi) + xi;\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\n/**\n * inBBox\n *\n * @private\n * @param {Position} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return (bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1]);\n}\n","import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n","import Supercluster from \"supercluster\";\nimport booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport { polygon } from \"@turf/helpers\";\n\nclass DataProcessor {\n  constructor(data) {\n    this.index = new Supercluster();\n    this.points = [];\n    // specific to t-SNE\n\n    console.log(\"Reading data...\");\n    data.split(\"\\n\").forEach((line) => {\n      const parts = line.split(\",\");\n      const x = parseFloat(parts[1]);\n      const y = parseFloat(parts[2]);\n      if (!parts[0] || isNaN(x) || isNaN(y)) {\n        return;\n      }\n      this.points.push({\n        geometry: {\n          coordinates: [x, y],\n          sample: parts[0],\n        },\n      });\n    });\n\n    console.log(\"Indexing data...\");\n    this.index.load(this.points);\n\n    console.log(\"Data ready.\");\n  }\n\n  selectBox(points, zoom = 16) {\n    const smallerX = Math.min(points[0], points[2]);\n    const smallerY = Math.min(points[1], points[3]);\n    const largerX = Math.max(points[0], points[2]);\n    const largerY = Math.max(points[1], points[3]);\n\n    console.log(\n      this.index.getClusters([smallerX, smallerY, largerX, largerY], zoom)\n    );\n  }\n\n  selectLasso(points, zoom = 16) {\n    let smallestX = Number.MAX_VALUE;\n    let largestX = Number.MIN_VALUE;\n    let smallestY = Number.MAX_VALUE;\n    let largestY = Number.MIN_VALUE;\n    const polygonPoints = [];\n    for (let i = 0; i < points.length; i += 2) {\n      if (points[i] < smallestX) smallestX = points[i];\n      if (points[i] > largestX) largestX = points[i];\n      if (points[i + 1] < smallestY) smallestY = points[i + 1];\n      if (points[i + 1] > largestY) largestY = points[i + 1];\n      polygonPoints.push([points[i], points[i + 1]]);\n    }\n\n    polygonPoints.push([...polygonPoints[0]]); // First and last must be same position\n\n    const candidatePoints = this.index.getClusters(\n      [smallestX, smallestY, largestX, largestY],\n      zoom\n    );\n    const boundingPolygon = polygon([polygonPoints]);\n\n    console.log(\n      candidatePoints.filter((point) => {\n        return booleanPointInPolygon(\n          point.geometry.coordinates,\n          boundingPolygon\n        );\n      })\n    );\n  }\n}\n\nexport default DataProcessor;\n"],"names":["$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$bundles","$2604e7ef843a7459f41771577fc9183c$export$default","ids","coords","nodeSize","left","right","depth","m","$2604e7ef843a7459f41771577fc9183c$var$select","k","inc","n","z","Math","log","s","exp","sd","sqrt","max","floor","min","t","i","j","$2604e7ef843a7459f41771577fc9183c$var$swapItem","$2604e7ef843a7459f41771577fc9183c$var$swap","arr","tmp","$096d289fcf1fd1a3473712905d88d713$var$sqDist","ax","ay","bx","by","dx","dy","$cec8aa2beba66738a8aba4c1486b720b$var$defaultGetX","p","$cec8aa2beba66738a8aba4c1486b720b$var$defaultGetY","$cec8aa2beba66738a8aba4c1486b720b$export$default","constructor","points","getX","getY","ArrayType","Float64Array","this","IndexArrayType","length","Uint16Array","Uint32Array","range","minX","minY","maxX","maxY","stack","result","x","y","axis","pop","push","nextAxis","within","r","qx","qy","r2","$df8fb0a35aa61306982e223b3fdb50ad$var$defaultOptions","minZoom","maxZoom","minPoints","radius","extent","generateId","reduce","map","props","$df8fb0a35aa61306982e223b3fdb50ad$var$fround","fround","Float32Array","$df8fb0a35aa61306982e223b3fdb50ad$export$default","options","$df8fb0a35aa61306982e223b3fdb50ad$var$extend","Object","create","trees","Array","load","console","time","timerId","clusters","geometry","$df8fb0a35aa61306982e223b3fdb50ad$var$createPointCluster","$df8fb0a35aa61306982e223b3fdb50ad$var$getX","$df8fb0a35aa61306982e223b3fdb50ad$var$getY","timeEnd","now","Date","_cluster","getClusters","bbox","zoom","minLng","minLat","maxLng","maxLat","easternHem","westernHem","concat","tree","_limitZoom","$df8fb0a35aa61306982e223b3fdb50ad$var$lngX","$df8fb0a35aa61306982e223b3fdb50ad$var$latY","id","c","numPoints","$df8fb0a35aa61306982e223b3fdb50ad$var$getClusterJSON","index","getChildren","clusterId","originId","_getOriginId","originZoom","_getOriginZoom","errorMsg","Error","origin","pow","children","parentId","getLeaves","limit","offset","leaves","_appendLeaves","getTile","z2","top","bottom","tile","features","_addTileFeatures","getClusterExpansionZoom","expansionZoom","properties","cluster_id","skipped","child","cluster","point_count","isCluster","tags","px","py","$df8fb0a35aa61306982e223b3fdb50ad$var$getClusterProperties","coordinates","f","type","round","undefined","neighborIds","numPointsOrigin","neighborId","b","wx","wy","clusterProperties","_map","numPoints2","$df8fb0a35aa61306982e223b3fdb50ad$var$createCluster","point","clone","original","Infinity","$df8fb0a35aa61306982e223b3fdb50ad$var$yLat","count","abbrev","point_count_abbreviated","lng","lat","sin","PI","y2","atan","dest","src","e","v","$f8afcd2ffd7e50afc2a4e6a9d6a8cb31$export$feature","geom","feat","$bd7e548c741d8ed512ad135051375ae7$export$default","polygon","geojson","pt","coord","isArray","polys","$bd7e548c741d8ed512ad135051375ae7$var$inBBox","insidePoly","$bd7e548c741d8ed512ad135051375ae7$var$inRing","ignoreBoundary","inHole","ring","isInside","slice","xi","yi","xj","yj","$467f05d4fa8d08894f84e9cd2c03a15c$export$default","data","split","forEach","line","parts","parseFloat","isNaN","sample","selectBox","smallerX","smallerY","largerX","largerY","selectLasso","smallestX","Number","MAX_VALUE","largestX","MIN_VALUE","smallestY","largestY","polygonPoints","candidatePoints","boundingPolygon","_i","coordinates_1","filter","defineProperty","get","enumerable","parcelRequire","name","wrapper","module","require","err","code","register","exports","registerBundle","fn","parcelRequireName"],"version":3,"file":"index.089c93f5.js.map"}