{"mappings":"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","sources":["./node_modules/@parcel/scope-hoisting/lib/helpers.js","./node_modules/@parcel/scope-hoisting/lib/prelude.js","./node_modules/kdbush/src/sort.js","./node_modules/kdbush/src/range.js","./node_modules/kdbush/src/within.js","./node_modules/kdbush/src/index.js","./node_modules/supercluster/index.js","./node_modules/@turf/helpers/dist/es/index.js","./node_modules/@turf/invariant/dist/es/index.js","./node_modules/@turf/boolean-point-in-polygon/dist/es/index.js","./src/scripts/data-processor.js"],"sourcesContent":["var $parcel$global =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n    ? self\n    : typeof window !== 'undefined'\n    ? window\n    : typeof global !== 'undefined'\n    ? global\n    : {};\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n}\n\nfunction $parcel$export(e, n, v) {\n  Object.defineProperty(e, n, {get: v, enumerable: true});\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n}\n\nfunction $parcel$missingModule(name) {\n  var err = new Error(\"Cannot find module '\" + name + \"'\");\n  err.code = 'MODULE_NOT_FOUND';\n  throw err;\n}\n","var $parcel$modules = {};\nvar $parcel$bundles = {};\n\nif (parcelRequire == null) {\n  parcelRequire = function(name) {\n    // Execute the bundle wrapper function if there is one registered.\n    if (name in $parcel$bundles) {\n      let wrapper = $parcel$bundles[name];\n      delete $parcel$bundles[name];\n      wrapper();\n    }\n\n    if (name in $parcel$modules) {\n      return $parcel$modules[name];\n    }\n\n    // Try the node require function if it exists.\n    // Do not use `require` to prevent Webpack from trying to bundle this call\n    if (typeof module !== 'undefined' && typeof module.require === 'function') {\n      return module.require(name);\n    }\n\n    var err = new Error(\"Cannot find module '\" + name + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, exports) {\n    $parcel$modules[id] = exports;\n  };\n\n  parcelRequire.registerBundle = function registerBundle(id, fn) {\n    $parcel$bundles[id] = fn;\n    $parcel$modules[id] = {};\n  };\n\n  $parcel$global[parcelRequireName] = parcelRequire;\n}\n","\nexport default function sortKD(ids, coords, nodeSize, left, right, depth) {\n    if (right - left <= nodeSize) return;\n\n    const m = (left + right) >> 1;\n\n    select(ids, coords, m, left, right, depth % 2);\n\n    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);\n    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);\n}\n\nfunction select(ids, coords, k, left, right, inc) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, inc);\n        }\n\n        const t = coords[2 * k + inc];\n        let i = left;\n        let j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + inc] < t) i++;\n            while (coords[2 * j + inc] > t) j--;\n        }\n\n        if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);\n        else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n","\nexport default function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    let x, y;\n\n    while (stack.length) {\n        const axis = stack.pop();\n        const right = stack.pop();\n        const left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (let i = left; i <= right; i++) {\n                x = coords[2 * i];\n                y = coords[2 * i + 1];\n                if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        const m = Math.floor((left + right) / 2);\n\n        x = coords[2 * m];\n        y = coords[2 * m + 1];\n\n        if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\n\n        const nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? minX <= x : minY <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? maxX >= x : maxY >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n","\nexport default function within(ids, coords, qx, qy, r, nodeSize) {\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    const r2 = r * r;\n\n    while (stack.length) {\n        const axis = stack.pop();\n        const right = stack.pop();\n        const left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (let i = left; i <= right; i++) {\n                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        const m = Math.floor((left + right) / 2);\n\n        const x = coords[2 * m];\n        const y = coords[2 * m + 1];\n\n        if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\n\n        const nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? qx - r <= x : qy - r <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? qx + r >= x : qy + r >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n\nfunction sqDist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n","\nimport sort from './sort';\nimport range from './range';\nimport within from './within';\n\nconst defaultGetX = p => p[0];\nconst defaultGetY = p => p[1];\n\nexport default class KDBush {\n    constructor(points, getX = defaultGetX, getY = defaultGetY, nodeSize = 64, ArrayType = Float64Array) {\n        this.nodeSize = nodeSize;\n        this.points = points;\n\n        const IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;\n\n        const ids = this.ids = new IndexArrayType(points.length);\n        const coords = this.coords = new ArrayType(points.length * 2);\n\n        for (let i = 0; i < points.length; i++) {\n            ids[i] = i;\n            coords[2 * i] = getX(points[i]);\n            coords[2 * i + 1] = getY(points[i]);\n        }\n\n        sort(ids, coords, nodeSize, 0, ids.length - 1, 0);\n    }\n\n    range(minX, minY, maxX, maxY) {\n        return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);\n    }\n\n    within(x, y, r) {\n        return within(this.ids, this.coords, x, y, r, this.nodeSize);\n    }\n}\n","\nimport KDBush from 'kdbush';\n\nconst defaultOptions = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    minPoints: 2, // minimum points to form a cluster\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: props => props // props => ({sum: props.my_value})\n};\n\nconst fround = Math.fround || (tmp => ((x) => { tmp[0] = +x; return tmp[0]; }))(new Float32Array(1));\n\nexport default class Supercluster {\n    constructor(options) {\n        this.options = extend(Object.create(defaultOptions), options);\n        this.trees = new Array(this.options.maxZoom + 1);\n    }\n\n    load(points) {\n        const {log, minZoom, maxZoom, nodeSize} = this.options;\n\n        if (log) console.time('total time');\n\n        const timerId = `prepare ${  points.length  } points`;\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        let clusters = [];\n        for (let i = 0; i < points.length; i++) {\n            if (!points[i].geometry) continue;\n            clusters.push(createPointCluster(points[i], i));\n        }\n        this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (let z = maxZoom; z >= minZoom; z--) {\n            const now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            clusters = this._cluster(clusters, z);\n            this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    }\n\n    getClusters(bbox, zoom) {\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        const tree = this.trees[this._limitZoom(zoom)];\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        const clusters = [];\n        for (const id of ids) {\n            const c = tree.points[id];\n            clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n        }\n        return clusters;\n    }\n\n    getChildren(clusterId) {\n        const originId = this._getOriginId(clusterId);\n        const originZoom = this._getOriginZoom(clusterId);\n        const errorMsg = 'No cluster with the specified id.';\n\n        const index = this.trees[originZoom];\n        if (!index) throw new Error(errorMsg);\n\n        const origin = index.points[originId];\n        if (!origin) throw new Error(errorMsg);\n\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        const ids = index.within(origin.x, origin.y, r);\n        const children = [];\n        for (const id of ids) {\n            const c = index.points[id];\n            if (c.parentId === clusterId) {\n                children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    }\n\n    getLeaves(clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        const leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    }\n\n    getTile(z, x, y) {\n        const tree = this.trees[this._limitZoom(z)];\n        const z2 = Math.pow(2, z);\n        const {extent, radius} = this.options;\n        const p = radius / extent;\n        const top = (y - p) / z2;\n        const bottom = (y + 1 + p) / z2;\n\n        const tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.points, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.points, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.points, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    }\n\n    getClusterExpansionZoom(clusterId) {\n        let expansionZoom = this._getOriginZoom(clusterId) - 1;\n        while (expansionZoom <= this.options.maxZoom) {\n            const children = this.getChildren(clusterId);\n            expansionZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return expansionZoom;\n    }\n\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\n        const children = this.getChildren(clusterId);\n\n        for (const child of children) {\n            const props = child.properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(child);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    }\n\n    _addTileFeatures(ids, points, x, y, z2, tile) {\n        for (const i of ids) {\n            const c = points[i];\n            const isCluster = c.numPoints;\n\n            let tags, px, py;\n            if (isCluster) {\n                tags = getClusterProperties(c);\n                px = c.x;\n                py = c.y;\n            } else {\n                const p = this.points[c.index];\n                tags = p.properties;\n                px = lngX(p.geometry.coordinates[0]);\n                py = latY(p.geometry.coordinates[1]);\n            }\n\n            const f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (px * z2 - x)),\n                    Math.round(this.options.extent * (py * z2 - y))\n                ]],\n                tags\n            };\n\n            // assign id\n            let id;\n            if (isCluster) {\n                id = c.id;\n            } else if (this.options.generateId) {\n                // optionally generate id\n                id = c.index;\n            } else if (this.points[c.index].id) {\n                // keep id if already assigned\n                id = this.points[c.index].id;\n            }\n\n            if (id !== undefined) f.id = id;\n\n            tile.features.push(f);\n        }\n    }\n\n    _limitZoom(z) {\n        return Math.max(this.options.minZoom, Math.min(+z, this.options.maxZoom + 1));\n    }\n\n    _cluster(points, zoom) {\n        const clusters = [];\n        const {radius, extent, reduce, minPoints} = this.options;\n        const r = radius / (extent * Math.pow(2, zoom));\n\n        // loop through each point\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            // if we've already visited the point at this zoom level, skip it\n            if (p.zoom <= zoom) continue;\n            p.zoom = zoom;\n\n            // find all nearby points\n            const tree = this.trees[zoom + 1];\n            const neighborIds = tree.within(p.x, p.y, r);\n\n            const numPointsOrigin = p.numPoints || 1;\n            let numPoints = numPointsOrigin;\n\n            // count the number of points in a potential cluster\n            for (const neighborId of neighborIds) {\n                const b = tree.points[neighborId];\n                // filter out neighbors that are already processed\n                if (b.zoom > zoom) numPoints += b.numPoints || 1;\n            }\n\n            if (numPoints >= minPoints) { // enough points to form a cluster\n                let wx = p.x * numPointsOrigin;\n                let wy = p.y * numPointsOrigin;\n\n                let clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null;\n\n                // encode both zoom and point index on which the cluster originated -- offset by total length of features\n                const id = (i << 5) + (zoom + 1) + this.points.length;\n\n                for (const neighborId of neighborIds) {\n                    const b = tree.points[neighborId];\n\n                    if (b.zoom <= zoom) continue;\n                    b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n                    const numPoints2 = b.numPoints || 1;\n                    wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\n                    wy += b.y * numPoints2;\n\n                    b.parentId = id;\n\n                    if (reduce) {\n                        if (!clusterProperties) clusterProperties = this._map(p, true);\n                        reduce(clusterProperties, this._map(b));\n                    }\n                }\n\n                p.parentId = id;\n                clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n\n            } else { // left points as unclustered\n                clusters.push(p);\n\n                if (numPoints > 1) {\n                    for (const neighborId of neighborIds) {\n                        const b = tree.points[neighborId];\n                        if (b.zoom <= zoom) continue;\n                        b.zoom = zoom;\n                        clusters.push(b);\n                    }\n                }\n            }\n        }\n\n        return clusters;\n    }\n\n    // get index of the point from which the cluster originated\n    _getOriginId(clusterId) {\n        return (clusterId - this.points.length) >> 5;\n    }\n\n    // get zoom of the point from which the cluster originated\n    _getOriginZoom(clusterId) {\n        return (clusterId - this.points.length) % 32;\n    }\n\n    _map(point, clone) {\n        if (point.numPoints) {\n            return clone ? extend({}, point.properties) : point.properties;\n        }\n        const original = this.points[point.index].properties;\n        const result = this.options.map(original);\n        return clone && result === original ? extend({}, result) : result;\n    }\n}\n\nfunction createCluster(x, y, id, numPoints, properties) {\n    return {\n        x: fround(x), // weighted cluster center; round for consistency with Float32Array index\n        y: fround(y),\n        zoom: Infinity, // the last zoom the cluster was processed at\n        id, // encodes index of the first child of the cluster and its zoom level\n        parentId: -1, // parent cluster id\n        numPoints,\n        properties\n    };\n}\n\nfunction createPointCluster(p, id) {\n    const [x, y] = p.geometry.coordinates;\n    return {\n        x: fround(lngX(x)), // projected point coordinates\n        y: fround(latY(y)),\n        zoom: Infinity, // the last zoom the point was processed at\n        index: id, // index of the source feature in the original input array,\n        parentId: -1 // parent cluster id\n    };\n}\n\nfunction getClusterJSON(cluster) {\n    return {\n        type: 'Feature',\n        id: cluster.id,\n        properties: getClusterProperties(cluster),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\n        }\n    };\n}\n\nfunction getClusterProperties(cluster) {\n    const count = cluster.numPoints;\n    const abbrev =\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\n    return extend(extend({}, cluster.properties), {\n        cluster: true,\n        cluster_id: cluster.id,\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    const sin = Math.sin(lat * Math.PI / 180);\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    const y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n    for (const id in src) dest[id] = src[id];\n    return dest;\n}\n\nfunction getX(p) {\n    return p.x;\n}\nfunction getY(p) {\n    return p.y;\n}\n","/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n","import { getCoord, getGeom } from \"@turf/invariant\";\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point\n * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Coord} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if\n * the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\nexport default function booleanPointInPolygon(point, polygon, options) {\n    if (options === void 0) { options = {}; }\n    // validation\n    if (!point) {\n        throw new Error(\"point is required\");\n    }\n    if (!polygon) {\n        throw new Error(\"polygon is required\");\n    }\n    var pt = getCoord(point);\n    var geom = getGeom(polygon);\n    var type = geom.type;\n    var bbox = polygon.bbox;\n    var polys = geom.coordinates;\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) {\n        return false;\n    }\n    // normalize to multipolygon\n    if (type === \"Polygon\") {\n        polys = [polys];\n    }\n    var insidePoly = false;\n    for (var i = 0; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) {\n                insidePoly = true;\n            }\n        }\n    }\n    return insidePoly;\n}\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] &&\n        ring[0][1] === ring[ring.length - 1][1]) {\n        ring = ring.slice(0, ring.length - 1);\n    }\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0];\n        var yi = ring[i][1];\n        var xj = ring[j][0];\n        var yj = ring[j][1];\n        var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 &&\n            (xi - pt[0]) * (xj - pt[0]) <= 0 &&\n            (yi - pt[1]) * (yj - pt[1]) <= 0;\n        if (onBoundary) {\n            return !ignoreBoundary;\n        }\n        var intersect = yi > pt[1] !== yj > pt[1] &&\n            pt[0] < ((xj - xi) * (pt[1] - yi)) / (yj - yi) + xi;\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\n/**\n * inBBox\n *\n * @private\n * @param {Position} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return (bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1]);\n}\n","import Supercluster from \"supercluster\";\nimport booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport { polygon } from \"@turf/helpers\";\n\nclass DataProcessor {\n  constructor(data) {\n    this.index = new Supercluster();\n    this.points = [];\n    // specific to t-SNE\n\n    console.log(\"Reading data...\");\n    data.split(\"\\n\").forEach((line) => {\n      const parts = line.split(\",\");\n      const x = parseFloat(parts[1]);\n      const y = parseFloat(parts[2]);\n      if (!parts[0] || isNaN(x) || isNaN(y)) {\n        return;\n      }\n      this.points.push({\n        geometry: {\n          coordinates: [x, y],\n          sample: parts[0],\n        },\n      });\n    });\n\n    console.log(\"Indexing data...\");\n    this.index.load(this.points);\n\n    console.log(\"Data ready.\");\n  }\n\n  selectBox(points, zoom = 16) {\n    const smallerX = Math.min(points[0], points[2]);\n    const smallerY = Math.min(points[1], points[3]);\n    const largerX = Math.max(points[0], points[2]);\n    const largerY = Math.max(points[1], points[3]);\n\n    console.log(\n      this.index.getClusters([smallerX, smallerY, largerX, largerY], zoom)\n    );\n  }\n\n  selectLasso(points, zoom = 16) {\n    let smallestX = Number.MAX_VALUE;\n    let largestX = Number.MIN_VALUE;\n    let smallestY = Number.MAX_VALUE;\n    let largestY = Number.MIN_VALUE;\n    const polygonPoints = [];\n    for (let i = 0; i < points.length; i += 2) {\n      if (points[i] < smallestX) smallestX = points[i];\n      if (points[i] > largestX) largestX = points[i];\n      if (points[i + 1] < smallestY) smallestY = points[i + 1];\n      if (points[i + 1] > largestY) largestY = points[i + 1];\n      polygonPoints.push([points[i], points[i + 1]]);\n    }\n\n    polygonPoints.push([...polygonPoints[0]]); // First and last must be same position\n\n    const candidatePoints = this.index.getClusters(\n      [smallestX, smallestY, largestX, largestY],\n      zoom\n    );\n    const boundingPolygon = polygon([polygonPoints]);\n\n    console.log(\n      candidatePoints.filter((point) => {\n        return booleanPointInPolygon(\n          point.geometry.coordinates,\n          boundingPolygon\n        );\n      })\n    );\n  }\n}\n\nexport default DataProcessor;\n"],"names":["$parcel$global","globalThis","self","window","global","e","n","v","Object","defineProperty","get","enumerable","$parcel$modules","$parcel$bundles","parcelRequire","name","wrapper","module","require","err","Error","code","register","id","exports","registerBundle","fn","parcelRequireName","ids","coords","nodeSize","left","right","depth","m","$2604e7ef843a7459f41771577fc9183c$var$select","$2604e7ef843a7459f41771577fc9183c$export$default","k","inc","z","Math","log","s","exp","sd","sqrt","newLeft","max","floor","newRight","min","t","i","j","$2604e7ef843a7459f41771577fc9183c$var$swapItem","$2604e7ef843a7459f41771577fc9183c$var$swap","arr","tmp","minX","minY","maxX","maxY","stack","length","result","x","y","axis","pop","push","nextAxis","qx","qy","r","r2","$096d289fcf1fd1a3473712905d88d713$var$sqDist","ax","ay","bx","by","dx","dy","$cec8aa2beba66738a8aba4c1486b720b$var$defaultGetX","p","$cec8aa2beba66738a8aba4c1486b720b$var$defaultGetY","constructor","points","getX","getY","ArrayType","Float64Array","IndexArrayType","Uint16Array","Uint32Array","range","within","$df8fb0a35aa61306982e223b3fdb50ad$var$defaultOptions","minZoom","maxZoom","minPoints","radius","extent","generateId","reduce","map","props","$df8fb0a35aa61306982e223b3fdb50ad$var$fround","fround","Float32Array","options","$df8fb0a35aa61306982e223b3fdb50ad$var$extend","create","trees","Array","load","console","time","timerId","clusters","geometry","$df8fb0a35aa61306982e223b3fdb50ad$var$createPointCluster","$df8fb0a35aa61306982e223b3fdb50ad$var$getX","$df8fb0a35aa61306982e223b3fdb50ad$var$getY","timeEnd","now","Date","_cluster","getClusters","bbox","zoom","minLng","minLat","maxLng","maxLat","easternHem","westernHem","concat","tree","_limitZoom","$df8fb0a35aa61306982e223b3fdb50ad$var$lngX","$df8fb0a35aa61306982e223b3fdb50ad$var$latY","c","numPoints","$df8fb0a35aa61306982e223b3fdb50ad$var$getClusterJSON","index","getChildren","clusterId","originId","_getOriginId","originZoom","_getOriginZoom","errorMsg","origin","pow","children","parentId","getLeaves","limit","offset","leaves","_appendLeaves","getTile","z2","top","bottom","tile","features","_addTileFeatures","getClusterExpansionZoom","expansionZoom","properties","cluster_id","skipped","child","cluster","point_count","isCluster","tags","px","py","$df8fb0a35aa61306982e223b3fdb50ad$var$getClusterProperties","coordinates","f","type","round","undefined","neighborIds","numPointsOrigin","neighborId","b","wx","wy","clusterProperties","_map","numPoints2","$df8fb0a35aa61306982e223b3fdb50ad$var$createCluster","point","clone","original","Infinity","$df8fb0a35aa61306982e223b3fdb50ad$var$xLng","$df8fb0a35aa61306982e223b3fdb50ad$var$yLat","count","abbrev","point_count_abbreviated","lng","lat","sin","PI","y2","atan","dest","src","$f8afcd2ffd7e50afc2a4e6a9d6a8cb31$export$earthRadius","$f8afcd2ffd7e50afc2a4e6a9d6a8cb31$export$factors","centimeters","centimetres","degrees","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","radians","yards","$f8afcd2ffd7e50afc2a4e6a9d6a8cb31$export$areaFactors","acres","hectares","geom","feat","isArray","$f8afcd2ffd7e50afc2a4e6a9d6a8cb31$export$isNumber","$f8afcd2ffd7e50afc2a4e6a9d6a8cb31$export$feature","_i","coordinates_1","ring","fc","units","factor","distance","num","isNaN","coord","$0f23bf02f02182a25d9fb3497411f2a2$export$containsNumber","geojson","polygon","pt","polys","$bd7e548c741d8ed512ad135051375ae7$var$inBBox","insidePoly","$bd7e548c741d8ed512ad135051375ae7$var$inRing","ignoreBoundary","inHole","isInside","slice","xi","yi","xj","yj","onBoundary","intersect","data","split","forEach","line","parts","parseFloat","sample","selectBox","smallerX","smallerY","largerX","largerY","selectLasso","smallestX","Number","MAX_VALUE","largestX","MIN_VALUE","smallestY","largestY","polygonPoints","candidatePoints","boundingPolygon","filter"],"version":3,"file":"index.dc12603f.js.map"}