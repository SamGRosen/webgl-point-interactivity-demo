{"mappings":"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","sources":["./src/scripts/utilities.js","./src/scripts/offscreen-webgl-worker.js","./src/scripts/webgl-drawer.js","./src/scripts/drawer.js","./src/scripts/webgl.js"],"sourcesContent":["function scale(domain, range) {\n  const domainLength = domain[1] - domain[0];\n  const rangeLength = range[1] - range[0];\n  const slope = rangeLength / domainLength;\n  const intercept = range[1] - slope * domain[1];\n  return (x) => slope * x + intercept;\n}\n\nfunction loadShader(gl, type, source) {\n  const shader = gl.createShader(type);\n\n  gl.shaderSource(shader, source);\n\n  gl.compileShader(shader);\n\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    console.error(`Could not compile shader: ${gl.getShaderInfoLog(shader)}`);\n    gl.deleteShader(shader);\n    return null;\n  }\n  return shader;\n}\n\nfunction initShaderProgram(gl, vertexSource, fragmentSource) {\n  const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vertexSource);\n  const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fragmentSource);\n\n  const shaderProgram = gl.createProgram();\n  gl.attachShader(shaderProgram, vertexShader);\n  gl.attachShader(shaderProgram, fragmentShader);\n  gl.linkProgram(shaderProgram);\n\n  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n    console.error(\n      `Unable to initialize the shader program: ${gl.getProgramInfoLog(\n        shaderProgram\n      )}`\n    );\n    return null;\n  }\n\n  return shaderProgram;\n}\n\nfunction componentToHex(c) {\n  var hex = c.toString(16);\n  return hex.length == 1 ? \"0\" + hex : hex;\n}\n\nfunction rgbToHex(r, g, b) {\n  return parseInt(\n    Number(\"0x\" + componentToHex(r) + componentToHex(g) + componentToHex(b)),\n    10\n  );\n}\n\nexport { scale, initShaderProgram, loadShader, rgbToHex };\n","import WebGLDrawer from \"./webgl-drawer\";\n\nclass OffscreenWebGLDrawer extends WebGLDrawer {\n  tick() {\n    postMessage({ type: \"tick\" });\n  }\n}\n\nself.onmessage = (message) => {\n  switch (message.data.type) {\n    case \"init\":\n      self.drawer = new OffscreenWebGLDrawer(message.data);\n      break;\n    case \"state\":\n      self.drawer.receiveState(message.data);\n      break;\n    case \"render\":\n      self.drawer.receiveState(message.data);\n      self.drawer.render();\n      break;\n    case \"buffer\":\n      self.drawer.populateBuffers(message.data.responseData);\n      break;\n    case \"clearBuffers\":\n      self.drawer.clearBuffers();\n      break;\n    default:\n      console.error(`Received unknown message type: ${message.type}`);\n  }\n};\n","import Drawer from \"./drawer\";\nimport { scale, initShaderProgram } from \"./utilities\";\nimport { colorPointsVertexShader, colorPointsFragmentShader } from \"./webgl.js\";\n\n// Largely taken from\n// https://github.com/mdn/webgl-examples/blob/gh-pages/tutorial/sample2/webgl-demo.js\n\nclass WebGLCanvasDrawer extends Drawer {\n  constructor(data) {\n    super(data);\n\n    this.gl = this.canvas.getContext(\"webgl\");\n\n    if (!this.gl) {\n      console.error(\"Unable to initialize WebGL!\");\n      return;\n    }\n\n    // Specific to t-SNE Dataset\n    this.sampleColors = new Map( // Create colors for sample type\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZ012\"\n        .split(\"\")\n        .map((letter) => [\n          letter,\n          [Math.random(), Math.random(), Math.random(), 0.01],\n        ])\n    );\n\n    this.xTSNEScale = scale([-10, 10], [-1, 1]);\n    this.yTSNEScale = scale([-10, 10], [-1, 1]);\n\n    this.positions = [];\n    this.colors = [];\n  }\n\n  getWebGLViewport() {\n    // Calculate appropriate webgl viewport given current selection window\n    const windowWidth = this.currentXRange[1] - this.currentXRange[0];\n    const windowHeight = this.currentYRange[1] - this.currentYRange[0];\n\n    const displayAsIfThisWide =\n      ((this.maxX - this.minX) / windowWidth) * this.width;\n    const displayAsIfThisHigh =\n      ((this.maxY - this.minY) / windowHeight) * this.height;\n\n    const scaleXWindowSpace = scale(\n      [this.minX, this.maxX],\n      [0, -displayAsIfThisWide]\n    );\n    const scaleYWindowSpace = scale(\n      [this.minY, this.maxY],\n      [0, -displayAsIfThisHigh]\n    );\n\n    const toReturnX = scaleXWindowSpace(this.currentXRange[0]);\n    const toReturnY = scaleYWindowSpace(this.currentYRange[0]);\n\n    return [toReturnX, toReturnY, displayAsIfThisWide, displayAsIfThisHigh];\n  }\n\n  populateBuffers(data) {\n    // Given raw data, populate the buffers\n    // Specific to t-SNE data\n    console.log(data);\n    data.split(\"\\n\").forEach((line) => {\n      const parts = line.split(\",\");\n      const x = parseFloat(parts[1]);\n      const y = parseFloat(parts[2]);\n      if (!parts[0] || !x || !y) {\n        return; // skip bad rows\n      }\n\n      this.positions.push(this.xTSNEScale(x), this.yTSNEScale(y));\n      console.log(parts);\n      console.log(this.sampleColors.get(parts[0]));\n      this.colors.push(...this.sampleColors.get(parts[0]));\n    });\n  }\n\n  clearBuffers() {\n    this.positions = [];\n    this.colors = [];\n  }\n\n  animate() {\n    if (!this.needsAnimation) {\n      this.lastFrame = requestAnimationFrame(this.animate.bind(this));\n      this.tick();\n      return;\n    }\n\n    this.gl.enable(this.gl.BLEND);\n    this.gl.blendFunc(this.gl.SRC_COLOR, this.gl.DST_COLOR);\n\n    // Clear the canvas before we start drawing on it.\n    this.gl.clearColor(0.0, 0.0, 0.0, 1.0);\n\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n\n    const viewport = this.getWebGLViewport();\n\n    this.gl.viewport(viewport[0], viewport[1], viewport[2], viewport[3]);\n\n    this.gl.drawArrays(\n      this.gl.POINTS,\n      0, // stride\n      this.vertexCount // vertex count\n    );\n\n    this.needsAnimation = false;\n    this.lastFrame = requestAnimationFrame(this.animate.bind(this));\n    this.tick();\n  }\n\n  render() {\n    super.render();\n\n    this.shaderProgram = initShaderProgram(\n      this.gl,\n      colorPointsVertexShader,\n      colorPointsFragmentShader\n    );\n\n    this.programInfo = {\n      program: this.shaderProgram,\n      attribLocations: {\n        vertexPosition: this.gl.getAttribLocation(\n          this.shaderProgram,\n          \"aVertexPosition\"\n        ),\n        vertexColor: this.gl.getAttribLocation(\n          this.shaderProgram,\n          \"aVertexColor\"\n        ),\n      },\n    };\n\n    // this.positions and this.colors populated by populateBuffers method used in Handler\n    this.vertexCount = this.positions.length / 2;\n    this.positionBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\n    this.gl.bufferData(\n      this.gl.ARRAY_BUFFER,\n      new Float32Array(this.positions),\n      this.gl.STATIC_DRAW\n    );\n\n    this.colorBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);\n    this.gl.bufferData(\n      this.gl.ARRAY_BUFFER,\n      new Float32Array(this.colors),\n      this.gl.STATIC_DRAW\n    );\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\n    this.gl.vertexAttribPointer(\n      this.programInfo.attribLocations.vertexPosition,\n      2, // numComponents\n      this.gl.FLOAT, // type\n      false, // normalize\n      0, // stride\n      0 // offset\n    );\n    this.gl.enableVertexAttribArray(\n      this.programInfo.attribLocations.vertexPosition\n    );\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);\n    this.gl.vertexAttribPointer(\n      this.programInfo.attribLocations.vertexColor,\n      4, // numComponents\n      this.gl.FLOAT, // type\n      false, // normalize\n      0, // stride\n      0 // offset\n    );\n    this.gl.enableVertexAttribArray(\n      this.programInfo.attribLocations.vertexColor\n    );\n\n    this.gl.useProgram(this.programInfo.program);\n\n    if (this.lastFrame) {\n      cancelAnimationFrame(this.lastFrame);\n    }\n    this.needsAnimation = true;\n    this.animate();\n  }\n}\n\nexport default WebGLCanvasDrawer;\n","class Drawer {\n  constructor(data) {\n    this.canvas = data.canvas;\n    this.width = data.canvas.width;\n    this.height = data.canvas.height;\n    this.receiveState(data);\n  }\n\n  receiveState(data) {\n    this.minX = data.minX;\n    this.maxX = data.maxX;\n    this.minY = data.minY;\n    this.maxY = data.maxY;\n    this.currentXRange = [...data.currentXRange];\n    this.currentYRange = [...data.currentYRange];\n\n    this.needsAnimation = true;\n  }\n\n  tick() {}\n\n  animate() {}\n\n  render() {\n    if (this.lastFrame) {\n      // Avoid overlapping animation requests\n      cancelAnimationFrame(this.lastFrame);\n    }\n  }\n}\n\nexport default Drawer;\n","const vertexShader = `\n  attribute vec4 aVertexPosition;\n\n  void main() {\n      gl_Position = aVertexPosition;\n  }\n`;\n\nconst squaresFragmentShader = `\n  precision mediump float;\n  uniform float uGridSize;\n  uniform vec4 viewport;\n  void main() {\n    vec4 ndcPos;\n    // Reverse calculations from window space to clip space (normalized device coordinates)\n    ndcPos.xy = ((2.0 * gl_FragCoord.xy) - (2.0 * viewport.xy)) / (viewport.zw) - 1.0;\n    ndcPos.xy = ndcPos.xy - mod(ndcPos.xy, 1.0 / uGridSize);\n    gl_FragColor = vec4(ndcPos.x/2.0 + 0.5 , 0, ndcPos.y/2.0 + 0.5, 1.0);\n  }\n`;\n\nconst colorPointsVertexShader = `\n  attribute vec4 aVertexPosition;\n  attribute vec4 aVertexColor;\n\n  varying lowp vec4 vColor;\n\n  void main(void) {\n    gl_Position = aVertexPosition;\n    vColor = aVertexColor;\n    gl_PointSize = 1.0;\n  }\n`;\n\nconst colorPointsFragmentShader = `\n  varying lowp vec4 vColor;\n\n  void main(void) {\n    gl_FragColor = vColor;\n  }\n`;\n\nexport {\n  vertexShader,\n  squaresFragmentShader,\n  colorPointsVertexShader,\n  colorPointsFragmentShader,\n};\n"],"names":["$aa6955df6e83d0bfaadb4927ac8c0161$export$scale","domain","range","domainLength","slope","intercept","x","$aa6955df6e83d0bfaadb4927ac8c0161$export$loadShader","gl","type","source","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","error","getShaderInfoLog","deleteShader","$587f3b939a351f7416b8a5ab7e7e2081$var$OffscreenWebGLDrawer","constructor","data","this","canvas","width","height","receiveState","minX","maxX","minY","maxY","currentXRange","currentYRange","needsAnimation","tick","animate","render","lastFrame","cancelAnimationFrame","super","getContext","sampleColors","Map","split","map","letter","Math","random","xTSNEScale","yTSNEScale","positions","colors","getWebGLViewport","windowWidth","windowHeight","displayAsIfThisWide","displayAsIfThisHigh","scaleXWindowSpace","scaleYWindowSpace","populateBuffers","log","forEach","line","parts","parseFloat","y","push","get","clearBuffers","requestAnimationFrame","bind","enable","BLEND","blendFunc","SRC_COLOR","DST_COLOR","clearColor","clear","COLOR_BUFFER_BIT","viewport","drawArrays","POINTS","vertexCount","shaderProgram","vertexSource","fragmentSource","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","$d4db4b0835c4c7737bdcc08b6fbcb412$export$colorPointsVertexShader","$d4db4b0835c4c7737bdcc08b6fbcb412$export$colorPointsFragmentShader","programInfo","program","attribLocations","vertexPosition","getAttribLocation","vertexColor","length","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","colorBuffer","vertexAttribPointer","FLOAT","enableVertexAttribArray","useProgram","postMessage","self","onmessage","message","drawer","responseData"],"version":3,"file":"offscreen-webgl-worker.141bdd58.js.map"}