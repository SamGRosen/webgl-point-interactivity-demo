{"mappings":"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","sources":["./src/scripts/drawer.js","./src/scripts/utilities.js","./src/scripts/webgl.js","./src/scripts/webgl-drawer.js","./src/scripts/offscreen-webgl-worker.js"],"sourcesContent":["class Drawer {\n  constructor(data) {\n    this.canvas = data.canvas;\n    this.width = data.canvas.width;\n    this.height = data.canvas.height;\n    this.receiveState(data);\n  }\n\n  receiveState(data) {\n    this.minX = data.minX;\n    this.maxX = data.maxX;\n    this.minY = data.minY;\n    this.maxY = data.maxY;\n    this.currentXRange = [...data.currentXRange];\n    this.currentYRange = [...data.currentYRange];\n\n    this.needsAnimation = true;\n  }\n\n  tick() {}\n\n  animate() {}\n\n  render() {\n    if (this.lastFrame) {\n      // Avoid overlapping animation requests\n      cancelAnimationFrame(this.lastFrame);\n    }\n  }\n}\n\nexport default Drawer;\n","function scale(domain, range) {\n  const domainLength = domain[1] - domain[0];\n  const rangeLength = range[1] - range[0];\n  const slope = rangeLength / domainLength;\n  const intercept = range[1] - slope * domain[1];\n  return (x) => slope * x + intercept;\n}\n\nfunction loadShader(gl, type, source) {\n  const shader = gl.createShader(type);\n\n  gl.shaderSource(shader, source);\n\n  gl.compileShader(shader);\n\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    console.error(`Could not compile shader: ${gl.getShaderInfoLog(shader)}`);\n    gl.deleteShader(shader);\n    return null;\n  }\n  return shader;\n}\n\nfunction initShaderProgram(gl, vertexSource, fragmentSource) {\n  const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vertexSource);\n  const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fragmentSource);\n\n  const shaderProgram = gl.createProgram();\n  gl.attachShader(shaderProgram, vertexShader);\n  gl.attachShader(shaderProgram, fragmentShader);\n  gl.linkProgram(shaderProgram);\n\n  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n    console.error(\n      `Unable to initialize the shader program: ${gl.getProgramInfoLog(\n        shaderProgram\n      )}`\n    );\n    return null;\n  }\n\n  return shaderProgram;\n}\n\nfunction componentToHex(c) {\n  var hex = c.toString(16);\n  return hex.length == 1 ? \"0\" + hex : hex;\n}\n\nfunction rgbToHex(r, g, b) {\n  return parseInt(\n    Number(\"0x\" + componentToHex(r) + componentToHex(g) + componentToHex(b)),\n    10\n  );\n}\n\nexport { scale, initShaderProgram, loadShader, rgbToHex };\n","const vertexShader = `\n  attribute vec4 aVertexPosition;\n\n  void main() {\n      gl_Position = aVertexPosition;\n  }\n`;\n\nconst squaresFragmentShader = `\n  precision mediump float;\n  uniform float uGridSize;\n  uniform vec4 viewport;\n  void main() {\n    vec4 ndcPos;\n    // Reverse calculations from window space to clip space (normalized device coordinates)\n    ndcPos.xy = ((2.0 * gl_FragCoord.xy) - (2.0 * viewport.xy)) / (viewport.zw) - 1.0;\n    ndcPos.xy = ndcPos.xy - mod(ndcPos.xy, 1.0 / uGridSize);\n    gl_FragColor = vec4(ndcPos.x/2.0 + 0.5 , 0, ndcPos.y/2.0 + 0.5, 1.0);\n  }\n`;\n\nconst colorPointsVertexShader = `\n  attribute vec4 aVertexPosition;\n  attribute vec4 aVertexColor;\n\n  varying lowp vec4 vColor;\n\n  void main(void) {\n    gl_Position = aVertexPosition;\n    vColor = aVertexColor;\n    gl_PointSize = 1.0;\n  }\n`;\n\nconst colorPointsFragmentShader = `\n  varying lowp vec4 vColor;\n\n  void main(void) {\n    gl_FragColor = vColor;\n  }\n`;\n\nexport {\n  vertexShader,\n  squaresFragmentShader,\n  colorPointsVertexShader,\n  colorPointsFragmentShader,\n};\n","import Drawer from \"./drawer\";\nimport { scale, initShaderProgram } from \"./utilities\";\nimport { colorPointsVertexShader, colorPointsFragmentShader } from \"./webgl.js\";\n\n// Largely taken from\n// https://github.com/mdn/webgl-examples/blob/gh-pages/tutorial/sample2/webgl-demo.js\n\nclass WebGLCanvasDrawer extends Drawer {\n  constructor(data) {\n    super(data);\n\n    this.gl = this.canvas.getContext(\"webgl\");\n\n    if (!this.gl) {\n      console.error(\"Unable to initialize WebGL!\");\n      return;\n    }\n\n    // Specific to t-SNE Dataset\n    this.sampleColors = new Map( // Create colors for sample type\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZ012\"\n        .split(\"\")\n        .map((letter) => [\n          letter,\n          [Math.random(), Math.random(), Math.random(), 0.01],\n        ])\n    );\n\n    this.xTSNEScale = scale([-10, 10], [-1, 1]);\n    this.yTSNEScale = scale([-10, 10], [-1, 1]);\n\n    this.positions = [];\n    this.colors = [];\n  }\n\n  getWebGLViewport() {\n    // Calculate appropriate webgl viewport given current selection window\n    const windowWidth = this.currentXRange[1] - this.currentXRange[0];\n    const windowHeight = this.currentYRange[1] - this.currentYRange[0];\n\n    const displayAsIfThisWide =\n      ((this.maxX - this.minX) / windowWidth) * this.width;\n    const displayAsIfThisHigh =\n      ((this.maxY - this.minY) / windowHeight) * this.height;\n\n    const scaleXWindowSpace = scale(\n      [this.minX, this.maxX],\n      [0, -displayAsIfThisWide]\n    );\n    const scaleYWindowSpace = scale(\n      [this.minY, this.maxY],\n      [0, -displayAsIfThisHigh]\n    );\n\n    const toReturnX = scaleXWindowSpace(this.currentXRange[0]);\n    const toReturnY = scaleYWindowSpace(this.currentYRange[0]);\n\n    return [toReturnX, toReturnY, displayAsIfThisWide, displayAsIfThisHigh];\n  }\n\n  populateBuffers(data) {\n    // Given raw data, populate the buffers\n    // Specific to t-SNE data\n    console.log(data);\n    data.split(\"\\n\").forEach((line) => {\n      const parts = line.split(\",\");\n      const x = parseFloat(parts[1]);\n      const y = parseFloat(parts[2]);\n      if (!parts[0] || !x || !y) {\n        return; // skip bad rows\n      }\n\n      this.positions.push(this.xTSNEScale(x), this.yTSNEScale(y));\n      this.colors.push(...this.sampleColors.get(parts[0]));\n    });\n  }\n\n  clearBuffers() {\n    this.positions = [];\n    this.colors = [];\n  }\n\n  animate() {\n    if (!this.needsAnimation) {\n      this.lastFrame = requestAnimationFrame(this.animate.bind(this));\n      this.tick();\n      return;\n    }\n\n    this.gl.enable(this.gl.BLEND);\n    this.gl.blendFunc(this.gl.SRC_COLOR, this.gl.DST_COLOR);\n\n    // Clear the canvas before we start drawing on it.\n    this.gl.clearColor(0.0, 0.0, 0.0, 1.0);\n\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n\n    const viewport = this.getWebGLViewport();\n\n    this.gl.viewport(viewport[0], viewport[1], viewport[2], viewport[3]);\n\n    this.gl.drawArrays(\n      this.gl.POINTS,\n      0, // stride\n      this.vertexCount // vertex count\n    );\n\n    this.needsAnimation = false;\n    this.lastFrame = requestAnimationFrame(this.animate.bind(this));\n    this.tick();\n  }\n\n  render() {\n    super.render();\n\n    this.shaderProgram = initShaderProgram(\n      this.gl,\n      colorPointsVertexShader,\n      colorPointsFragmentShader\n    );\n\n    this.programInfo = {\n      program: this.shaderProgram,\n      attribLocations: {\n        vertexPosition: this.gl.getAttribLocation(\n          this.shaderProgram,\n          \"aVertexPosition\"\n        ),\n        vertexColor: this.gl.getAttribLocation(\n          this.shaderProgram,\n          \"aVertexColor\"\n        ),\n      },\n    };\n\n    // this.positions and this.colors populated by populateBuffers method used in Handler\n    this.vertexCount = this.positions.length / 2;\n    this.positionBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\n    this.gl.bufferData(\n      this.gl.ARRAY_BUFFER,\n      new Float32Array(this.positions),\n      this.gl.STATIC_DRAW\n    );\n\n    this.colorBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);\n    this.gl.bufferData(\n      this.gl.ARRAY_BUFFER,\n      new Float32Array(this.colors),\n      this.gl.STATIC_DRAW\n    );\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\n    this.gl.vertexAttribPointer(\n      this.programInfo.attribLocations.vertexPosition,\n      2, // numComponents\n      this.gl.FLOAT, // type\n      false, // normalize\n      0, // stride\n      0 // offset\n    );\n    this.gl.enableVertexAttribArray(\n      this.programInfo.attribLocations.vertexPosition\n    );\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);\n    this.gl.vertexAttribPointer(\n      this.programInfo.attribLocations.vertexColor,\n      4, // numComponents\n      this.gl.FLOAT, // type\n      false, // normalize\n      0, // stride\n      0 // offset\n    );\n    this.gl.enableVertexAttribArray(\n      this.programInfo.attribLocations.vertexColor\n    );\n\n    this.gl.useProgram(this.programInfo.program);\n\n    if (this.lastFrame) {\n      cancelAnimationFrame(this.lastFrame);\n    }\n    this.needsAnimation = true;\n    this.animate();\n  }\n}\n\nexport default WebGLCanvasDrawer;\n","import WebGLDrawer from \"./webgl-drawer\";\n\nclass OffscreenWebGLDrawer extends WebGLDrawer {\n  tick() {\n    postMessage({ type: \"tick\" });\n  }\n}\n\nself.onmessage = (message) => {\n  switch (message.data.type) {\n    case \"init\":\n      self.drawer = new OffscreenWebGLDrawer(message.data);\n      break;\n    case \"state\":\n      self.drawer.receiveState(message.data);\n      break;\n    case \"render\":\n      self.drawer.receiveState(message.data);\n      self.drawer.render();\n      break;\n    case \"buffer\":\n      self.drawer.populateBuffers(message.data.responseData);\n      break;\n    case \"clearBuffers\":\n      self.drawer.clearBuffers();\n      break;\n    default:\n      console.error(`Received unknown message type: ${message.type}`);\n  }\n};\n"],"names":["constructor","data","canvas","width","height","receiveState","minX","maxX","minY","maxY","currentXRange","currentYRange","needsAnimation","tick","animate","render","lastFrame","cancelAnimationFrame","domain","range","domainLength","rangeLength","slope","intercept","x","gl","type","source","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","error","getShaderInfoLog","deleteShader","vertexSource","fragmentSource","vertexShader","$aa6955df6e83d0bfaadb4927ac8c0161$export$loadShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","shaderProgram","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","c","hex","toString","length","r","g","b","parseInt","Number","$aa6955df6e83d0bfaadb4927ac8c0161$var$componentToHex","$d4db4b0835c4c7737bdcc08b6fbcb412$export$vertexShader","$d4db4b0835c4c7737bdcc08b6fbcb412$export$squaresFragmentShader","$d4db4b0835c4c7737bdcc08b6fbcb412$export$colorPointsVertexShader","$d4db4b0835c4c7737bdcc08b6fbcb412$export$colorPointsFragmentShader","getContext","sampleColors","Map","split","map","letter","Math","random","xTSNEScale","yTSNEScale","positions","colors","getWebGLViewport","windowWidth","windowHeight","displayAsIfThisWide","displayAsIfThisHigh","scaleXWindowSpace","scaleYWindowSpace","toReturnX","toReturnY","populateBuffers","log","forEach","line","parts","parseFloat","y","push","get","clearBuffers","requestAnimationFrame","bind","enable","BLEND","blendFunc","SRC_COLOR","DST_COLOR","clearColor","clear","COLOR_BUFFER_BIT","viewport","drawArrays","POINTS","vertexCount","programInfo","program","attribLocations","vertexPosition","getAttribLocation","vertexColor","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","colorBuffer","vertexAttribPointer","FLOAT","enableVertexAttribArray","useProgram","postMessage","self","onmessage","message","drawer","$587f3b939a351f7416b8a5ab7e7e2081$var$OffscreenWebGLDrawer","responseData"],"version":3,"file":"offscreen-webgl-worker.de52ed19.js.map"}